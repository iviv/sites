<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DKIM Signature Validator</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-primary: #0a0e14;
            --bg-secondary: #0d1117;
            --bg-tertiary: #161b22;
            --accent: #00ff88;
            --accent-secondary: #00d4ff;
            --accent-glow: rgba(0, 255, 136, 0.3);
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-dim: #484f58;
            --border: #30363d;
            --error: #ff6b7a;
            --warning: #ffb347;
            --success: #00ff88;
            --glass: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
        }

        [data-theme="light"] {
            --bg-primary: #fafafa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f0f0f0;
            --accent: #50a14f;
            --accent-secondary: #4078f2;
            --accent-glow: rgba(80, 161, 79, 0.15);
            --text-primary: #383a42;
            --text-secondary: #696c77;
            --text-dim: #a0a1a7;
            --border: #e5e5e6;
            --error: #e45649;
            --warning: #c18401;
            --success: #50a14f;
            --glass: rgba(56, 58, 66, 0.03);
            --glass-border: rgba(56, 58, 66, 0.08);
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            transition: background 0.3s, color 0.3s;
        }

        /* Background */
        .bg-grid {
            position: fixed;
            inset: 0;
            background-image: linear-gradient(var(--glass-border) 1px, transparent 1px),
                              linear-gradient(90deg, var(--glass-border) 1px, transparent 1px);
            background-size: 60px 60px;
            opacity: 0.5;
            pointer-events: none;
            animation: gridMove 30s linear infinite;
        }
        @keyframes gridMove { to { transform: translate(60px, 60px); } }

        .bg-orb {
            position: fixed;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.4;
            pointer-events: none;
            animation: float 20s ease-in-out infinite;
        }
        .bg-orb:nth-child(2) { width: 400px; height: 400px; background: var(--accent); top: -100px; right: -100px; }
        .bg-orb:nth-child(3) { width: 300px; height: 300px; background: var(--accent-secondary); bottom: -50px; left: -50px; animation-delay: -7s; }
        @keyframes float {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(-20px, 20px) scale(0.95); }
        }

        /* Layout */
        .container { position: relative; z-index: 1; max-width: 1100px; margin: 0 auto; padding: 2rem; }

        /* Header */
        header { text-align: center; margin-bottom: 2rem; position: relative; }
        .theme-toggle {
            position: absolute;
            top: 0;
            right: 0;
            width: 44px;
            height: 44px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.25rem;
            transition: all 0.3s;
        }
        .theme-toggle:hover { border-color: var(--accent); transform: rotate(20deg); }
        
        .logo { display: inline-flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem; }
        .logo-icon {
            width: 56px; height: 56px;
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            border-radius: 16px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.75rem;
            box-shadow: 0 8px 32px var(--accent-glow);
        }
        h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: var(--text-secondary); font-size: 0.85rem; }
        .privacy { color: var(--text-dim); font-size: 0.75rem; margin-top: 0.75rem; }

        /* Input */
        .input-section {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            backdrop-filter: blur(20px);
        }
        .input-section:focus-within { border-color: var(--accent); box-shadow: 0 0 30px var(--accent-glow); }
        .input-label { display: flex; align-items: center; gap: 0.5rem; font-weight: 500; margin-bottom: 0.75rem; }
        textarea {
            width: 100%;
            height: 250px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            resize: vertical;
        }
        textarea:focus { outline: none; border-color: var(--accent); }
        textarea::placeholder { color: var(--text-dim); }
        
        .input-footer { display: flex; align-items: center; gap: 1rem; margin-top: 1rem; flex-wrap: wrap; }
        .btn {
            padding: 0.75rem 1.5rem;
            background: var(--glass);
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.85rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn:hover { border-color: var(--accent); color: var(--accent); }
        .status { color: var(--text-dim); font-size: 0.8rem; display: flex; align-items: center; gap: 0.5rem; }
        .spinner { width: 16px; height: 16px; border: 2px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Results */
        .results { display: none; }
        .results.visible { display: block; animation: fadeIn 0.4s; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } }

        /* Headers Section */
        .headers-section {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 1.25rem;
            margin-bottom: 1.5rem;
        }
        .section-header { font-weight: 600; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem; }
        .tags-grid { display: flex; flex-wrap: wrap; gap: 0.5rem; }
        
        /* Tag Base */
        .tag {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.5rem 0.7rem;
            font-size: 0.72rem;
            font-family: 'JetBrains Mono', monospace;
            transition: all 0.2s;
        }
        .tag:hover { border-color: var(--accent); }
        .tag .dot { width: 6px; height: 6px; border-radius: 50%; background: var(--text-dim); flex-shrink: 0; }
        .tag-name { color: var(--text-secondary); font-weight: 500; }
        .tag-value { color: var(--text-dim); max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .copy-btn {
            background: none; border: none; color: var(--text-dim); cursor: pointer;
            opacity: 0; transition: opacity 0.2s; margin-left: auto; padding: 0 0.2rem;
        }
        .tag:hover .copy-btn { opacity: 1; }
        .copy-btn:hover { color: var(--accent); }
        .copy-btn.copied { color: var(--success); opacity: 1; }

        /* Signed Tag */
        .tag.signed {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.08), rgba(0, 212, 255, 0.05));
            border-color: var(--accent);
        }
        .tag.signed .dot { background: linear-gradient(135deg, var(--success), var(--accent)); box-shadow: 0 0 6px var(--accent-glow); }
        .tag.signed .tag-name { color: var(--accent); font-weight: 600; }

        /* DNS Tag */
        .tag.dns .dot { background: var(--accent-secondary); }
        .tag.dns .tag-name { color: var(--accent-secondary); }

        /* Legend */
        .legend { display: flex; gap: 1rem; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border); }
        .legend-item { display: flex; align-items: center; gap: 0.4rem; font-size: 0.68rem; color: var(--text-dim); }

        /* Summary */
        .summary { display: flex; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
        .summary-item {
            display: flex; align-items: center; gap: 0.75rem;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1rem 1.25rem;
        }
        .summary-icon { width: 40px; height: 40px; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 1.1rem; background: var(--glass); border: 1px solid var(--border); }
        .summary-value { font-family: 'JetBrains Mono', monospace; font-size: 1.5rem; font-weight: 700; }
        .summary-value.success { color: var(--success); }
        .summary-value.error { color: var(--error); }
        .summary-label { font-size: 0.75rem; color: var(--text-secondary); }

        /* Signature Card */
        .sig-card {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            margin-bottom: 1rem;
            overflow: hidden;
        }
        .sig-card.valid { border-color: var(--success); }
        .sig-card.invalid { border-color: var(--error); }
        .sig-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 1rem 1.25rem;
            background: var(--bg-tertiary);
            cursor: pointer;
        }
        .sig-header:hover { background: var(--border); }
        .sig-title { display: flex; align-items: center; gap: 0.75rem; }
        .sig-num { width: 28px; height: 28px; background: var(--glass); border: 1px solid var(--border); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; color: var(--accent); }
        .sig-domain { font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; }
        .badge { padding: 0.35rem 0.75rem; border-radius: 20px; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; }
        .badge.valid { background: rgba(0, 255, 136, 0.15); color: var(--success); }
        .badge.invalid { background: rgba(255, 107, 122, 0.15); color: var(--error); }
        .expand-icon { color: var(--text-secondary); transition: transform 0.3s; }
        .sig-card.expanded .expand-icon { transform: rotate(180deg); }
        .sig-content { max-height: 0; overflow: hidden; transition: max-height 0.4s; }
        .sig-card.expanded .sig-content { max-height: 2000px; }
        .sig-body { padding: 1.25rem; }
        .sig-section { margin-bottom: 1.25rem; }
        .sig-section:last-child { margin-bottom: 0; }
        .sig-section-title { font-size: 0.75rem; font-weight: 600; color: var(--accent); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 0.5rem; }

        /* DNS Section */
        .dns-cmd {
            display: flex; align-items: center; gap: 0.5rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            margin-bottom: 0.75rem;
        }
        .dns-cmd code { flex: 1; font-family: 'JetBrains Mono', monospace; font-size: 0.78rem; color: var(--accent); }
        .dns-raw {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.68rem;
            color: var(--text-dim);
            word-break: break-all;
            max-height: 80px;
            overflow-y: auto;
            margin-top: 0.75rem;
        }

        /* Verification Details */
        .details { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 10px; }
        .detail-row { display: flex; justify-content: space-between; padding: 0.7rem 1rem; }
        .detail-row:hover { background: var(--glass); }
        .detail-label { color: var(--text-secondary); font-size: 0.78rem; }
        .detail-value { font-family: 'JetBrains Mono', monospace; font-size: 0.78rem; text-align: right; }
        .detail-value.success { color: var(--success); font-weight: 600; }
        .detail-value.error { color: var(--error); font-weight: 600; }

        /* Error */
        .error-msg {
            background: rgba(255, 107, 122, 0.1);
            border: 1px solid var(--error);
            border-radius: 10px;
            padding: 1rem;
            color: var(--error);
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }

        /* Debug */
        .debug { background: var(--glass); border: 1px solid var(--glass-border); border-radius: 12px; margin-top: 1.5rem; }
        .debug-header { padding: 1rem; background: var(--bg-tertiary); cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; color: var(--text-secondary); }
        .debug-body { max-height: 0; overflow: hidden; transition: max-height 0.4s; }
        .debug.expanded .debug-body { max-height: 500px; }
        .debug.expanded .expand-icon { transform: rotate(180deg); }
        .debug-log { padding: 1rem; background: var(--bg-secondary); max-height: 300px; overflow-y: auto; }
        .log-entry { font-size: 0.72rem; padding: 0.3rem 0; display: flex; gap: 0.75rem; font-family: 'JetBrains Mono', monospace; }
        .log-time { color: var(--text-dim); }
        .log-type { width: 50px; font-weight: 600; }
        .log-type.info { color: var(--accent); }
        .log-type.error { color: var(--error); }
        .log-type.success { color: var(--success); }
        .log-type.warn { color: var(--warning); }
        .log-msg { color: var(--text-secondary); word-break: break-all; }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 0.75rem 1rem;
            min-width: 200px;
            max-width: 300px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s ease-out, visibility 0.15s ease-out;
            z-index: 9999;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
            pointer-events: auto;
        }
        .tooltip.visible { opacity: 1; visibility: visible; }
        .tooltip-title { font-weight: 600; color: var(--accent); font-size: 0.8rem; margin-bottom: 0.25rem; font-family: 'JetBrains Mono', monospace; }
        .tooltip-desc { color: var(--text-secondary); font-size: 0.72rem; line-height: 1.4; }
        .tooltip-value { margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border); color: var(--text-primary); font-size: 0.68rem; font-family: 'JetBrains Mono', monospace; word-break: break-all; max-height: 60px; overflow-y: auto; }

        /* Toast */
        .toast {
            position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%) translateY(100px);
            background: var(--bg-secondary); border: 1px solid var(--accent); color: var(--text-primary);
            padding: 0.75rem 1.5rem; border-radius: 10px; font-size: 0.85rem; z-index: 9999;
            opacity: 0; transition: all 0.3s; display: flex; align-items: center; gap: 0.5rem;
        }
        .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

        @media (max-width: 640px) {
            .container { padding: 1rem; }
            h1 { font-size: 1.5rem; }
            .summary { flex-direction: column; }
            .theme-toggle { position: static; margin-bottom: 1rem; }
            header { text-align: left; }
        }
    </style>
</head>
<body>
    <div class="bg-grid"></div>
    <div class="bg-orb"></div>
    <div class="bg-orb"></div>
    
    <div class="tooltip" id="tooltip">
        <div class="tooltip-title" id="tooltipTitle"></div>
        <div class="tooltip-desc" id="tooltipDesc"></div>
        <div class="tooltip-value" id="tooltipValue"></div>
    </div>
    
    <div class="toast" id="toast"><span>‚úì</span><span id="toastMsg">Copied!</span></div>

    <div class="container">
        <header>
            <button class="theme-toggle" onclick="toggleTheme()" id="themeBtn">üåô</button>
            <div class="logo">
                <div class="logo-icon">üîê</div>
                <div>
                    <h1>DKIM Validator</h1>
                    <p class="subtitle">RFC 6376 Cryptographic Signature Verification</p>
                </div>
            </div>
            <p class="privacy">100% client-side ¬∑ No data sent to servers ¬∑ DNS queries only for public key retrieval</p>
        </header>

        <div class="input-section">
            <label class="input-label">üìß Raw Email Headers & Body</label>
            <textarea id="input" placeholder="Paste raw email content here..."></textarea>
            <div class="input-footer">
                <button class="btn" onclick="clearAll()">üóëÔ∏è Clear</button>
                <span class="status" id="status"></span>
            </div>
        </div>

        <div class="results" id="results">
            <div id="headersEl"></div>
            <div class="summary" id="summaryEl"></div>
            <div id="sigsEl"></div>
            <div class="debug" id="debugEl">
                <div class="debug-header" onclick="this.parentElement.classList.toggle('expanded')">
                    <span>üîç Debug Log</span>
                    <span class="expand-icon">‚ñº</span>
                </div>
                <div class="debug-body">
                    <div class="debug-log" id="debugLog"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // Tag descriptions
    const DKIM_TAGS = {
        v: { name: 'Version', desc: 'DKIM signature version (must be "1")' },
        a: { name: 'Algorithm', desc: 'Signing algorithm (e.g., rsa-sha256)' },
        b: { name: 'Signature', desc: 'Base64-encoded cryptographic signature' },
        bh: { name: 'Body Hash', desc: 'Hash of canonicalized message body' },
        c: { name: 'Canonicalization', desc: 'Header/body normalization method' },
        d: { name: 'Domain', desc: 'Signing domain identifier (SDID)' },
        s: { name: 'Selector', desc: 'DNS selector for public key lookup' },
        h: { name: 'Signed Headers', desc: 'Headers included in signature' },
        t: { name: 'Timestamp', desc: 'Signature creation time (Unix)' },
        x: { name: 'Expiration', desc: 'Signature expiration time (Unix)' },
        l: { name: 'Body Length', desc: 'Number of body bytes signed' },
        i: { name: 'Identity', desc: 'Agent/user identifier (AUID)' }
    };

    const DNS_TAGS = {
        v: { name: 'Version', desc: 'DKIM key record version (must be "DKIM1")' },
        k: { name: 'Key Type', desc: 'Type of key (default: rsa)' },
        p: { name: 'Public Key', desc: 'Base64-encoded public key data' },
        h: { name: 'Hash Algorithms', desc: 'Acceptable hash algorithms' },
        t: { name: 'Flags', desc: 'Flags (y=testing, s=strict)' }
    };

    // State
    const logs = [];
    let validateTimeout;

    // Theme
    function toggleTheme() {
        const html = document.documentElement;
        const btn = document.getElementById('themeBtn');
        const isDark = html.dataset.theme === 'dark';
        html.dataset.theme = isDark ? 'light' : 'dark';
        btn.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
        localStorage.setItem('theme', html.dataset.theme);
    }
    
    (function initTheme() {
        const saved = localStorage.getItem('theme');
        if (saved) {
            document.documentElement.dataset.theme = saved;
            document.getElementById('themeBtn').textContent = saved === 'dark' ? 'üåô' : '‚òÄÔ∏è';
        }
    })();

    // Utils
    function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
    function log(type, msg) { logs.push({ time: new Date().toISOString().split('T')[1].split('.')[0], type, msg }); }
    function showToast(msg) {
        const t = document.getElementById('toast');
        document.getElementById('toastMsg').textContent = msg;
        t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 2000);
    }
    function copy(btn, val) {
        navigator.clipboard.writeText(val);
        btn.classList.add('copied');
        const orig = btn.textContent;
        btn.textContent = '‚úì';
        setTimeout(() => { btn.classList.remove('copied'); btn.textContent = orig; }, 1500);
        showToast('Copied!');
    }

    // Clear
    function clearAll() {
        document.getElementById('input').value = '';
        document.getElementById('results').classList.remove('visible');
        document.getElementById('status').innerHTML = '';
    }

    // Auto-validate
    document.getElementById('input').addEventListener('input', () => {
        clearTimeout(validateTimeout);
        const val = document.getElementById('input').value.trim();
        if (!val || val.length < 50) {
            document.getElementById('results').classList.remove('visible');
            document.getElementById('status').innerHTML = '';
            return;
        }
        document.getElementById('status').innerHTML = '<div class="spinner"></div> Validating...';
        validateTimeout = setTimeout(validate, 400);
    });

    // Tooltip Manager
    const Tooltip = {
        el: null,
        hideTimer: null,
        activeTag: null,

        init() {
            this.el = document.getElementById('tooltip');
            // Keep tooltip open when hovering over it
            this.el.addEventListener('mouseenter', () => this.cancelHide());
            this.el.addEventListener('mouseleave', () => this.scheduleHide());
        },

        show(tag) {
            this.cancelHide();
            this.activeTag = tag;

            const { tag: name, tagName, tagDesc, tagValue } = tag.dataset;
            document.getElementById('tooltipTitle').textContent =
                tag.classList.contains('header') ? tagName : `${tagName} (${name}=)`;
            document.getElementById('tooltipDesc').textContent = tagDesc;
            document.getElementById('tooltipValue').textContent = tagValue;

            // Position tooltip
            const r = tag.getBoundingClientRect();
            let left = r.left;
            let top = r.bottom + 10;

            // Adjust if overflowing right
            if (left + 300 > window.innerWidth) {
                left = window.innerWidth - 320;
            }
            if (left < 10) left = 10;

            // Adjust if overflowing bottom
            if (top + 150 > window.innerHeight) {
                top = r.top - 160;
            }

            this.el.style.left = left + 'px';
            this.el.style.top = top + 'px';
            this.el.classList.add('visible');
        },

        hide() {
            this.el.classList.remove('visible');
            this.activeTag = null;
        },

        cancelHide() {
            if (this.hideTimer) {
                clearTimeout(this.hideTimer);
                this.hideTimer = null;
            }
        },

        scheduleHide() {
            this.cancelHide();
            this.hideTimer = setTimeout(() => this.hide(), 250);
        },

        // Attach events to a tag element
        attachToTag(tag) {
            tag.addEventListener('mouseenter', (e) => {
                if (!e.target.closest('.copy-btn')) {
                    this.show(tag);
                }
            });
            tag.addEventListener('mouseleave', () => {
                this.scheduleHide();
            });
        }
    };

    Tooltip.init();

    // Toggle card
    function toggleCard(el) { el.closest('.sig-card').classList.toggle('expanded'); }

    // Parse email
    function parseEmail(raw) {
        let headerSection, body;
        let idx = raw.indexOf('\r\n\r\n');
        if (idx !== -1) { headerSection = raw.slice(0, idx); body = raw.slice(idx + 4); }
        else { idx = raw.indexOf('\n\n'); headerSection = raw.slice(0, idx); body = raw.slice(idx + 2); }

        // Normalize to \r\n for consistent processing
        headerSection = headerSection.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n/g, '\r\n');
        const headers = [];
        let cur = null;
        for (const line of headerSection.split('\r\n')) {
            if (/^[ \t]/.test(line) && cur) {
                cur.raw += '\r\n' + line;
                cur.value += '\r\n' + line;
            } else {
                if (cur) headers.push({ name: cur.name, value: cur.value, raw: cur.raw });
                const i = line.indexOf(':');
                if (i > 0) {
                    cur = {
                        name: line.slice(0, i),
                        value: line.slice(i + 1),
                        raw: line
                    };
                } else {
                    cur = null;
                }
            }
        }
        if (cur) headers.push({ name: cur.name, value: cur.value, raw: cur.raw });

        const dkimSigs = headers.filter(h => h.name.toLowerCase() === 'dkim-signature').map(h => ({
            raw: h.raw,
            parsed: parseDkimTags(h.raw)
        }));

        return { headers, body, dkimSigs };
    }

    function parseDkimTags(raw) {
        const unfolded = raw.replace(/\r?\n[ \t]+/g, ' ');
        const match = unfolded.match(/DKIM-Signature:\s*(.+)/i);
        if (!match) return null;
        const tags = {};
        const re = /([a-z]+)\s*=\s*([^;]+)/gi;
        let m;
        while ((m = re.exec(match[1]))) {
            let val = m[2].trim();
            if (m[1] === 'b' || m[1] === 'bh') val = val.replace(/\s+/g, '');
            tags[m[1].toLowerCase()] = val;
        }
        return tags;
    }

    function parseDnsTags(record) {
        const tags = {};
        const re = /([a-z]+)\s*=\s*([^;]+)/gi;
        let m;
        while ((m = re.exec(record))) tags[m[1].toLowerCase()] = m[2].trim();
        return tags;
    }

    // Canonicalization
    function canonHeaderRelaxed(name, value) {
        let v = value.replace(/\r?\n[ \t]+/g, ' ').replace(/[ \t]+/g, ' ').trim();
        return name.toLowerCase() + ':' + v;
    }

    function canonBodyRelaxed(body) {
        if (!body) return '\r\n';
        let c = body.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n/g, '\r\n');
        c = c.split('\r\n').map(l => l.replace(/[ \t]+/g, ' ').replace(/ +$/, '')).join('\r\n');
        c = c.replace(/(\r\n)+$/, '') || '';
        return c + '\r\n';
    }

    function canonBodySimple(body) {
        if (!body) return '\r\n';
        let c = body.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n/g, '\r\n');
        c = c.replace(/(\r\n)+$/, '') || '';
        return c + '\r\n';
    }

    // DNS
    async function fetchDns(domain, selector) {
        const name = `${selector}._domainkey.${domain}`;
        log('info', `DNS lookup: ${name}`);
        try {
            const res = await fetch(`https://cloudflare-dns.com/dns-query?name=${encodeURIComponent(name)}&type=TXT`, {
                headers: { Accept: 'application/dns-json' }
            });
            const data = await res.json();
            if (data.Answer) {
                let record = '';
                for (const a of data.Answer) if (a.type === 16) record += a.data.replace(/^"|"$/g, '').replace(/" "/g, '');
                log('success', `DNS found: ${record.slice(0, 80)}...`);
                return { ok: true, record, name };
            }
            return { ok: false, error: 'No TXT record', name };
        } catch (e) {
            log('error', `DNS error: ${e.message}`);
            return { ok: false, error: e.message, name };
        }
    }

    // Crypto
    function b64ToBuffer(b64) {
        const bin = atob(b64.replace(/\s+/g, ''));
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
        return arr.buffer;
    }

    async function importKey(b64) {
        const keyData = b64ToBuffer(b64);
        try {
            return await crypto.subtle.importKey('spki', keyData, { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' }, false, ['verify']);
        } catch {
            const spki = convertPkcs1ToSpki(new Uint8Array(keyData));
            return await crypto.subtle.importKey('spki', spki, { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' }, false, ['verify']);
        }
    }

    function convertPkcs1ToSpki(pkcs1) {
        const oid = new Uint8Array([0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00]);
        const bitStr = new Uint8Array(pkcs1.length + 1);
        bitStr[0] = 0x00;
        bitStr.set(pkcs1, 1);
        const bsHeader = asn1Len(0x03, bitStr.length);
        const innerLen = oid.length + bsHeader.length + bitStr.length;
        const seqHeader = asn1Len(0x30, innerLen);
        const spki = new Uint8Array(seqHeader.length + oid.length + bsHeader.length + bitStr.length);
        let o = 0;
        spki.set(seqHeader, o); o += seqHeader.length;
        spki.set(oid, o); o += oid.length;
        spki.set(bsHeader, o); o += bsHeader.length;
        spki.set(bitStr, o);
        return spki.buffer;
    }

    function asn1Len(tag, len) {
        if (len < 128) return new Uint8Array([tag, len]);
        if (len < 256) return new Uint8Array([tag, 0x81, len]);
        return new Uint8Array([tag, 0x82, (len >> 8) & 0xff, len & 0xff]);
    }

    async function computeBodyHash(body, canon, limit) {
        let c = canon === 'relaxed' ? canonBodyRelaxed(body) : canonBodySimple(body);
        if (limit !== undefined && limit !== '') {
            const n = parseInt(limit, 10);
            if (!isNaN(n) && n >= 0) {
                const bytes = new TextEncoder().encode(c);
                if (bytes.length > n) c = new TextDecoder().decode(bytes.slice(0, n));
            }
        }
        const hash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(c));
        return btoa(String.fromCharCode(...new Uint8Array(hash)));
    }

    function buildSigningInput(headers, tags, rawDkim, headerCanon) {
        const signed = tags.h.split(':').map(h => h.trim().toLowerCase());
        const headerMap = new Map();
        for (const hdr of headers) {
            const ln = hdr.name.toLowerCase();
            if (!headerMap.has(ln)) headerMap.set(ln, []);
            headerMap.get(ln).push(hdr);
        }
        const lines = [];
        for (const h of signed) {
            const stack = headerMap.get(h);
            if (stack?.length) {
                const hdr = stack.pop();
                if (headerCanon === 'relaxed') {
                    lines.push(canonHeaderRelaxed(hdr.name, hdr.value));
                } else {
                    // Simple canonicalization: use exact raw header
                    lines.push(hdr.raw);
                }
            }
        }
        // Handle DKIM-Signature header for signing (with b= emptied)
        if (headerCanon === 'relaxed') {
            let dkimUnfolded = rawDkim.replace(/\r?\n[ \t]+/g, ' ');
            dkimUnfolded = dkimUnfolded.replace(/(;\s*b\s*=\s*)[A-Za-z0-9+/=\s]+/i, '$1');
            lines.push(canonHeaderRelaxed('DKIM-Signature', dkimUnfolded.replace(/^DKIM-Signature:\s*/i, '')));
        } else {
            // Simple: keep folding, just empty the b= value
            // The b= value can span multiple lines with folding, so match any base64 chars plus whitespace including \r\n
            let dkimSimple = rawDkim.replace(/(;\s*b\s*=\s*)[A-Za-z0-9+/=\r\n\t ]+/i, '$1');
            lines.push(dkimSimple);
        }
        return lines.join('\r\n');
    }

    async function verifySig(input, sig, key) {
        try {
            return await crypto.subtle.verify('RSASSA-PKCS1-v1_5', key, b64ToBuffer(sig), new TextEncoder().encode(input));
        } catch { return false; }
    }

    // Verify signature
    async function verifyDkim(sig, headers, body) {
        const tags = sig.parsed;
        const result = { domain: tags.d || '?', selector: tags.s || '?', tags, raw: sig.raw, status: 'invalid', errors: [], details: {} };
        
        const required = ['v', 'a', 'b', 'bh', 'd', 'h', 's'];
        for (const t of required) if (!tags[t]) result.errors.push(`Missing tag: ${t}`);
        if (result.errors.length) return result;
        if (tags.v !== '1') { result.errors.push(`Unsupported version: ${tags.v}`); return result; }
        if (tags.a !== 'rsa-sha256') { result.errors.push(`Unsupported algorithm: ${tags.a}`); return result; }

        const [hCanon, bCanon] = (tags.c || 'simple/simple').split('/');
        result.details.headerCanon = hCanon || 'simple';
        result.details.bodyCanon = bCanon || hCanon || 'simple';

        const dns = await fetchDns(tags.d, tags.s);
        result.dns = dns;
        if (!dns.ok) { result.errors.push(`DNS failed: ${dns.error}`); return result; }
        
        result.dnsTags = parseDnsTags(dns.record);
        if (!result.dnsTags.p) { result.errors.push('No public key in DNS'); return result; }

        const computedBh = await computeBodyHash(body, result.details.bodyCanon, tags.l);
        result.details.computedBh = computedBh;
        result.details.declaredBh = tags.bh;
        result.details.bhMatch = computedBh === tags.bh;
        if (!result.details.bhMatch) result.errors.push('Body hash mismatch');

        try {
            const key = await importKey(result.dnsTags.p);
            const input = buildSigningInput(headers, tags, sig.raw, result.details.headerCanon);
            result.details.sigValid = await verifySig(input, tags.b, key);
            if (!result.details.sigValid) result.errors.push('Signature verification failed');
        } catch (e) {
            result.errors.push(`Crypto error: ${e.message}`);
            result.details.sigValid = false;
        }

        result.status = result.details.bhMatch && result.details.sigValid ? 'valid' : 'invalid';
        log(result.status === 'valid' ? 'success' : 'error', `${tags.d}: ${result.status.toUpperCase()}`);
        return result;
    }

    // Render
    function renderTag(name, value, info, classes = '') {
        const short = value.length > 25 ? value.slice(0, 25) + '‚Ä¶' : value;
        return `<div class="tag ${classes}" data-tag="${esc(name)}" data-tag-name="${esc(info.name)}" data-tag-desc="${esc(info.desc)}" data-tag-value="${esc(value)}">
            <span class="dot"></span>
            <span class="tag-name">${esc(name)}</span>
            <span class="tag-value">${esc(short)}</span>
            <button class="copy-btn" onclick="event.stopPropagation();copy(this,\`${esc(value.replace(/`/g, ''))}\`)">‚ßâ</button>
        </div>`;
    }

    function renderHeaders(headers, signed) {
        const tags = headers.map(hdr => {
            const isSigned = signed.has(hdr.name.toLowerCase());
            // Unfold value for display
            const displayValue = hdr.value.replace(/\r?\n[ \t]+/g, ' ').trim();
            return renderTag(hdr.name, displayValue, { name: hdr.name, desc: isSigned ? 'Included in DKIM signature' : 'Not signed' }, `header ${isSigned ? 'signed' : ''}`);
        }).join('');
        return `<div class="headers-section">
            <div class="section-header">üì® Email Headers</div>
            <div class="tags-grid">${tags}</div>
            <div class="legend">
                <div class="legend-item"><span class="dot" style="background:linear-gradient(135deg,var(--success),var(--accent));width:6px;height:6px;border-radius:50%"></span> Signed</div>
                <div class="legend-item"><span class="dot" style="background:var(--text-dim);width:6px;height:6px;border-radius:50%"></span> Not signed</div>
            </div>
        </div>`;
    }

    function renderSig(r, i) {
        const errHtml = r.errors.map(e => `<div class="error-msg">${esc(e)}</div>`).join('');
        const dkimTags = Object.entries(r.tags).map(([k, v]) => renderTag(k, v, DKIM_TAGS[k] || { name: k.toUpperCase(), desc: 'DKIM tag' }, 'signed')).join('');
        const dnsTags = r.dnsTags ? Object.entries(r.dnsTags).map(([k, v]) => renderTag(k, v, DNS_TAGS[k] || { name: k.toUpperCase(), desc: 'DNS tag' }, 'dns')).join('') : '';
        const dnsCmd = `dig TXT ${r.dns?.name || r.selector + '._domainkey.' + r.domain}`;

        return `<div class="sig-card ${r.status} expanded">
            <div class="sig-header" onclick="toggleCard(this)">
                <div class="sig-title">
                    <span class="sig-num">${i}</span>
                    <span class="sig-domain">${esc(r.domain)}</span>
                    <span class="badge ${r.status}">${r.status === 'valid' ? '‚úì PASS' : '‚úó FAIL'}</span>
                </div>
                <span class="expand-icon">‚ñº</span>
            </div>
            <div class="sig-content"><div class="sig-body">
                ${errHtml}
                <div class="sig-section">
                    <div class="sig-section-title">üè∑Ô∏è DKIM Tags</div>
                    <div class="tags-grid">${dkimTags}</div>
                </div>
                <div class="sig-section">
                    <div class="sig-section-title">üåê DNS Record</div>
                    <div class="dns-cmd">
                        <code>${esc(dnsCmd)}</code>
                        <button class="copy-btn" style="opacity:1" onclick="event.stopPropagation();copy(this,'${esc(dnsCmd)}')">‚ßâ</button>
                    </div>
                    ${r.dns?.ok ? `<div class="tags-grid">${dnsTags}</div><div class="dns-raw">${esc(r.dns.record)}</div>` : `<div class="error-msg">${esc(r.dns?.error || 'DNS lookup failed')}</div>`}
                </div>
                <div class="sig-section">
                    <div class="sig-section-title">üîê Verification</div>
                    <div class="details">
                        <div class="detail-row"><span class="detail-label">Algorithm</span><span class="detail-value">${esc(r.tags.a || 'N/A')}</span></div>
                        <div class="detail-row"><span class="detail-label">Canonicalization</span><span class="detail-value">${r.details.headerCanon}/${r.details.bodyCanon}</span></div>
                        <div class="detail-row"><span class="detail-label">Body Hash</span><span class="detail-value ${r.details.bhMatch ? 'success' : 'error'}">${r.details.bhMatch ? '‚úì Match' : '‚úó Mismatch'}</span></div>
                        <div class="detail-row"><span class="detail-label">Signature</span><span class="detail-value ${r.details.sigValid ? 'success' : 'error'}">${r.details.sigValid ? '‚úì Valid' : '‚úó Invalid'}</span></div>
                    </div>
                </div>
            </div></div>
        </div>`;
    }

    function renderDebug() {
        return logs.map(l => `<div class="log-entry"><span class="log-time">${l.time}</span><span class="log-type ${l.type}">${l.type.toUpperCase()}</span><span class="log-msg">${esc(l.msg)}</span></div>`).join('');
    }

    // Initialize tooltips on all tags in the results
    function initTooltips() {
        document.querySelectorAll('#results .tag').forEach(tag => {
            Tooltip.attachToTag(tag);
        });
    }

    // Main validate
    async function validate() {
        logs.length = 0;
        const input = document.getElementById('input').value.trim();
        if (!input) return;

        log('info', 'Starting validation');
        const { headers, body, dkimSigs } = parseEmail(input);
        
        const signed = new Set();
        dkimSigs.forEach(s => s.parsed?.h?.split(':').forEach(h => signed.add(h.trim().toLowerCase())));
        
        document.getElementById('headersEl').innerHTML = renderHeaders(headers, signed);

        if (!dkimSigs.length) {
            document.getElementById('summaryEl').innerHTML = '';
            document.getElementById('sigsEl').innerHTML = '<div class="error-msg">No DKIM-Signature headers found</div>';
            document.getElementById('debugLog').innerHTML = renderDebug();
            document.getElementById('results').classList.add('visible');
            document.getElementById('status').innerHTML = '';
            initTooltips();
            return;
        }

        const results = [];
        for (const sig of dkimSigs) {
            results.push(await verifyDkim(sig, headers, body));
        }

        const valid = results.filter(r => r.status === 'valid').length;
        const invalid = results.length - valid;

        document.getElementById('summaryEl').innerHTML = `
            <div class="summary-item"><div class="summary-icon">üìß</div><div><span class="summary-value">${results.length}</span><div class="summary-label">Signatures</div></div></div>
            <div class="summary-item"><div class="summary-icon">‚úì</div><div><span class="summary-value success">${valid}</span><div class="summary-label">Valid</div></div></div>
            <div class="summary-item"><div class="summary-icon">‚úó</div><div><span class="summary-value error">${invalid}</span><div class="summary-label">Invalid</div></div></div>
        `;

        document.getElementById('sigsEl').innerHTML = results.map((r, i) => renderSig(r, i + 1)).join('');
        document.getElementById('debugLog').innerHTML = renderDebug();
        document.getElementById('results').classList.add('visible');
        document.getElementById('status').innerHTML = '';
        initTooltips();
    }
    </script>
</body>
</html>
