<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DKIM Signature Validator</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-primary: #0a0e14;
            --bg-secondary: #0d1117;
            --bg-tertiary: #161b22;
            --accent: #00ff88;
            --accent-secondary: #00d4ff;
            --accent-glow: rgba(0, 255, 136, 0.3);
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-dim: #484f58;
            --border: #30363d;
            --error: #ff6b7a;
            --warning: #ffb347;
            --success: #00ff88;
            --glass: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
        }

        [data-theme="light"] {
            --bg-primary: #fafafa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f0f0f0;
            --accent: #50a14f;
            --accent-secondary: #4078f2;
            --accent-glow: rgba(80, 161, 79, 0.15);
            --text-primary: #383a42;
            --text-secondary: #696c77;
            --text-dim: #a0a1a7;
            --border: #e5e5e6;
            --error: #e45649;
            --warning: #c18401;
            --success: #50a14f;
            --glass: rgba(56, 58, 66, 0.03);
            --glass-border: rgba(56, 58, 66, 0.08);
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            transition: background 0.3s, color 0.3s;
        }


        /* Layout */
        .container { position: relative; z-index: 1; max-width: 1100px; margin: 0 auto; padding: 2rem; }

        /* Header */
        header { text-align: center; margin-bottom: 2rem; position: relative; }
        .theme-toggle {
            position: absolute;
            top: 0;
            right: 0;
            width: 44px;
            height: 44px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.25rem;
            transition: all 0.3s;
        }
        .theme-toggle:hover { border-color: var(--accent); transform: rotate(20deg); }
        
        .logo { display: inline-flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem; }
        .logo-icon {
            width: 56px; height: 56px;
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            border-radius: 16px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.75rem;
            box-shadow: 0 8px 32px var(--accent-glow);
        }
        h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: var(--text-secondary); font-size: 0.85rem; }
        .privacy { color: var(--text-dim); font-size: 0.75rem; margin-top: 0.75rem; }

        /* Input */
        .input-section {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            backdrop-filter: blur(20px);
        }
        .input-section:focus-within { border-color: var(--accent); box-shadow: 0 0 30px var(--accent-glow); }
        .input-label { display: flex; align-items: center; gap: 0.5rem; font-weight: 500; margin-bottom: 0.75rem; }
        textarea {
            width: 100%;
            height: 250px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            resize: vertical;
        }
        textarea:focus { outline: none; border-color: var(--accent); }
        textarea::placeholder { color: var(--text-dim); }
        
        .input-footer { display: flex; align-items: center; gap: 1rem; margin-top: 1rem; flex-wrap: wrap; }
        .btn {
            padding: 0.75rem 1.5rem;
            background: var(--glass);
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.85rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn:hover { border-color: var(--accent); color: var(--accent); }
        .status { color: var(--text-dim); font-size: 0.8rem; display: flex; align-items: center; gap: 0.5rem; }
        .spinner { width: 16px; height: 16px; border: 2px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Results */
        .results { display: none; }
        .results.visible { display: block; animation: fadeIn 0.4s; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } }

        /* Headers Section */
        .headers-section {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 1.25rem;
            margin-bottom: 1.5rem;
        }
        .section-header { font-weight: 600; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem; }
        .tags-grid { display: flex; flex-wrap: wrap; gap: 0.5rem; }
        
        /* Tag Base */
        .tag {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.5rem 0.7rem;
            font-size: 0.72rem;
            font-family: 'JetBrains Mono', monospace;
            transition: all 0.2s;
        }
        .tag:hover { border-color: var(--accent); }
        .tag .dot { width: 6px; height: 6px; border-radius: 50%; background: var(--text-dim); flex-shrink: 0; }
        .tag-name { color: var(--text-secondary); font-weight: 500; }
        .tag-value { color: var(--text-dim); max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .copy-btn {
            background: none; border: none; color: var(--text-dim); cursor: pointer;
            opacity: 0; transition: opacity 0.2s; margin-left: auto; padding: 0 0.2rem;
        }
        .tag:hover .copy-btn { opacity: 1; }
        .copy-btn:hover { color: var(--accent); }
        .copy-btn.copied { color: var(--success); opacity: 1; }

        /* Signed Tag */
        .tag.signed {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.08), rgba(0, 212, 255, 0.05));
            border-color: var(--accent);
        }
        .tag.signed .dot { background: linear-gradient(135deg, var(--success), var(--accent)); box-shadow: 0 0 6px var(--accent-glow); }
        .tag.signed .tag-name { color: var(--accent); font-weight: 600; }

        /* DNS Tag */
        .tag.dns .dot { background: var(--accent-secondary); }
        .tag.dns .tag-name { color: var(--accent-secondary); }

        /* SPF Tags */
        .tag.spf-pass .dot { background: var(--success); }
        .tag.spf-pass .tag-name { color: var(--success); }
        .tag.spf-fail .dot { background: var(--error); }
        .tag.spf-fail .tag-name { color: var(--error); }
        .tag.spf-softfail .dot { background: var(--warning); }
        .tag.spf-softfail .tag-name { color: var(--warning); }
        .tag.spf-neutral .dot { background: var(--text-secondary); }
        .tag.spf-neutral .tag-name { color: var(--text-secondary); }

        /* SPF Card */
        .spf-card {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            margin-bottom: 1rem;
            overflow: hidden;
        }
        .spf-card.found { border-color: var(--accent-secondary); }
        .spf-card.notfound { border-color: var(--warning); }
        .spf-card .sig-content { max-height: 0; overflow: hidden; transition: max-height 0.4s; }
        .spf-card.expanded .sig-content { max-height: 2000px; }
        .spf-card.expanded .expand-icon { transform: rotate(180deg); }

        /* Relay Card */
        .relay-card {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            margin-bottom: 1rem;
            overflow: hidden;
        }
        .relay-card .sig-content { max-height: 0; overflow: hidden; transition: max-height 0.4s; }
        .relay-card.expanded .sig-content { max-height: 2000px; }
        .relay-card.expanded .expand-icon { transform: rotate(180deg); }

        /* DMARC Card */
        .dmarc-card {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            margin-bottom: 1rem;
            overflow: hidden;
        }
        .dmarc-card.reject { border-color: var(--success); }
        .dmarc-card.quarantine { border-color: var(--warning); }
        .dmarc-card.none { border-color: var(--text-secondary); }
        .dmarc-card.notfound { border-color: var(--error); }
        .dmarc-card .sig-content { max-height: 0; overflow: hidden; transition: max-height 0.4s; }
        .dmarc-card.expanded .sig-content { max-height: 2000px; }
        .dmarc-card.expanded .expand-icon { transform: rotate(180deg); }

        /* DMARC Tags */
        .tag.dmarc-reject .dot { background: var(--success); }
        .tag.dmarc-reject .tag-name { color: var(--success); }
        .tag.dmarc-quarantine .dot { background: var(--warning); }
        .tag.dmarc-quarantine .tag-name { color: var(--warning); }
        .tag.dmarc-none .dot { background: var(--text-secondary); }
        .tag.dmarc-none .tag-name { color: var(--text-secondary); }

        /* SPF Trace */
        .spf-trace {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }
        .spf-trace-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .spf-domain-trace {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
        }
        .spf-domain-trace:last-child { margin-bottom: 0; }
        .spf-domain-trace.depth-0 { border-left: 3px solid var(--accent); }
        .spf-domain-trace.depth-1 { margin-left: 1rem; border-left: 3px solid var(--info); }
        .spf-domain-trace.depth-2 { margin-left: 2rem; border-left: 3px solid var(--warning); }
        .spf-domain-trace.depth-3 { margin-left: 3rem; border-left: 3px solid var(--text-secondary); }
        .spf-domain-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .spf-domain-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        .spf-domain-depth {
            font-size: 0.65rem;
            color: var(--text-dim);
            background: var(--bg-tertiary);
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
        }
        .spf-record-preview {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            background: var(--bg-tertiary);
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            word-break: break-all;
            max-height: 60px;
            overflow: hidden;
        }
        .spf-mechanisms-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        .spf-mech {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            padding: 0.3rem 0.5rem;
            border-radius: 4px;
            background: var(--bg-tertiary);
        }
        .spf-mech.matched {
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid var(--success);
        }
        .spf-mech.not-matched { opacity: 0.6; }
        .spf-mech-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .spf-mech.matched .spf-mech-indicator { background: var(--success); }
        .spf-mech.not-matched .spf-mech-indicator { background: var(--text-dim); }
        .spf-mech-text { color: var(--text-primary); flex-grow: 1; }
        .spf-mech-details { color: var(--text-dim); font-size: 0.65rem; }
        .spf-match-path {
            margin-top: 1rem;
            padding: 0.75rem;
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid var(--success);
            border-radius: 8px;
        }
        .spf-match-path-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--success);
            margin-bottom: 0.5rem;
        }
        .spf-match-path-chain {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
        }
        .spf-match-path-item {
            background: var(--bg-secondary);
            padding: 0.3rem 0.5rem;
            border-radius: 4px;
            color: var(--text-primary);
        }
        .spf-match-path-arrow { color: var(--success); font-weight: bold; }

        /* ARC Card */
        .arc-card {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            margin-bottom: 1rem;
            overflow: hidden;
        }
        .arc-card.pass { border-color: var(--success); }
        .arc-card.fail { border-color: var(--error); }
        .arc-card.none { border-color: var(--text-secondary); }
        .arc-card .sig-content { max-height: 0; overflow: hidden; transition: max-height 0.4s; }
        .arc-card.expanded .sig-content { max-height: 3000px; }
        .arc-card.expanded .expand-icon { transform: rotate(180deg); }

        /* ARC Set */
        .arc-set {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 0.75rem;
        }
        .arc-set:last-child { margin-bottom: 0; }
        .arc-set-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        .arc-set-title { font-weight: 600; font-size: 0.8rem; color: var(--accent); }
        .arc-set-domain { font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; color: var(--text-secondary); }
        .arc-component { margin-bottom: 0.5rem; }
        .arc-component:last-child { margin-bottom: 0; }
        .arc-component-label { font-size: 0.7rem; color: var(--text-dim); margin-bottom: 0.3rem; }

        /* Relay Timeline */
        .relay-timeline { position: relative; padding-left: 24px; }
        .relay-hop {
            position: relative;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
        }
        .relay-hop::before {
            content: '';
            position: absolute;
            left: -20px;
            top: 50%;
            width: 12px;
            height: 12px;
            background: var(--accent);
            border-radius: 50%;
            transform: translateY(-50%);
            box-shadow: 0 0 8px var(--accent-glow);
        }
        .relay-hop::after {
            content: '';
            position: absolute;
            left: -14px;
            top: calc(50% + 6px);
            width: 2px;
            height: calc(100% + 0.5rem);
            background: var(--border);
        }
        .relay-hop:last-child::after { display: none; }
        .relay-hop.origin::before { background: var(--success); }
        .relay-hop-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4rem; }
        .relay-hop-server { font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; color: var(--text-primary); font-weight: 500; }
        .relay-hop-time { font-size: 0.7rem; color: var(--text-dim); }
        .relay-hop-details { display: flex; gap: 1rem; flex-wrap: wrap; }
        .relay-hop-detail { font-size: 0.72rem; color: var(--text-secondary); }
        .relay-hop-detail span { color: var(--text-dim); }
        .relay-latency {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.2rem 0.5rem;
            background: var(--glass);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
        }
        .relay-latency.fast { color: var(--success); border-color: var(--success); }
        .relay-latency.medium { color: var(--warning); border-color: var(--warning); }
        .relay-latency.slow { color: var(--error); border-color: var(--error); }
        .relay-summary-row { display: flex; gap: 1.5rem; margin-bottom: 1rem; flex-wrap: wrap; }
        .relay-stat {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.75rem;
        }
        .relay-stat-value { font-family: 'JetBrains Mono', monospace; font-weight: 600; color: var(--accent); }

        /* Legend */
        .legend { display: flex; gap: 1rem; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border); }
        .legend-item { display: flex; align-items: center; gap: 0.4rem; font-size: 0.68rem; color: var(--text-dim); }

        /* Summary */
        .summary { display: flex; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
        .summary-item {
            display: flex; align-items: center; gap: 0.75rem;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1rem 1.25rem;
        }
        .summary-icon { width: 40px; height: 40px; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 1.1rem; background: var(--glass); border: 1px solid var(--border); }
        .summary-value { font-family: 'JetBrains Mono', monospace; font-size: 1.5rem; font-weight: 700; }
        .summary-value.success { color: var(--success); }
        .summary-value.error { color: var(--error); }
        .summary-label { font-size: 0.75rem; color: var(--text-secondary); }

        /* Signature Card */
        .sig-card {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            margin-bottom: 1rem;
            overflow: hidden;
        }
        .sig-card.valid { border-color: var(--success); }
        .sig-card.invalid { border-color: var(--error); }
        .sig-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 1rem 1.25rem;
            background: var(--bg-tertiary);
            cursor: pointer;
        }
        .sig-header:hover { background: var(--border); }
        .sig-title { display: flex; align-items: center; gap: 0.75rem; }
        .sig-num { width: 28px; height: 28px; background: var(--glass); border: 1px solid var(--border); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; color: var(--accent); }
        .sig-domain { font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; }
        .badge { padding: 0.35rem 0.75rem; border-radius: 20px; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; }
        .badge.valid { background: rgba(0, 255, 136, 0.15); color: var(--success); }
        .badge.invalid { background: rgba(255, 107, 122, 0.15); color: var(--error); }
        .expand-icon { color: var(--text-secondary); transition: transform 0.3s; }
        .sig-card.expanded .expand-icon { transform: rotate(180deg); }
        .sig-content { max-height: 0; overflow: hidden; transition: max-height 0.4s; }
        .sig-card.expanded .sig-content { max-height: 2000px; }
        .sig-body { padding: 1.25rem; }
        .sig-section { margin-bottom: 1.25rem; }
        .sig-section:last-child { margin-bottom: 0; }
        .sig-section-title { font-size: 0.75rem; font-weight: 600; color: var(--accent); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 0.5rem; }

        /* DNS Section */
        .dns-cmd {
            display: flex; align-items: center; gap: 0.5rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            margin-bottom: 0.75rem;
        }
        .dns-cmd code { flex: 1; font-family: 'JetBrains Mono', monospace; font-size: 0.78rem; color: var(--accent); }
        .dns-raw {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.68rem;
            color: var(--text-dim);
            word-break: break-all;
            max-height: 80px;
            overflow-y: auto;
            margin-top: 0.75rem;
        }

        /* Verification Details */
        .details { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 10px; }
        .detail-row { display: flex; justify-content: space-between; padding: 0.7rem 1rem; }
        .detail-row:hover { background: var(--glass); }
        .detail-label { color: var(--text-secondary); font-size: 0.78rem; }
        .detail-value { font-family: 'JetBrains Mono', monospace; font-size: 0.78rem; text-align: right; }
        .detail-value.success { color: var(--success); font-weight: 600; }
        .detail-value.error { color: var(--error); font-weight: 600; }
        .detail-value.warning { color: var(--warning); font-weight: 600; }
        .detail-value.neutral { color: var(--text-secondary); }

        /* Error */
        .error-msg {
            background: rgba(255, 107, 122, 0.1);
            border: 1px solid var(--error);
            border-radius: 10px;
            padding: 1rem;
            color: var(--error);
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }

        /* Warning */
        .warning-msg {
            background: rgba(255, 179, 71, 0.1);
            border: 1px solid var(--warning);
            border-radius: 10px;
            padding: 1rem;
            color: var(--warning);
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }
        .warning-msg .suggestion, .error-msg .suggestion {
            display: block;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Parsing Issues Section */
        .parsing-issues {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 1.25rem;
            margin-bottom: 1.5rem;
        }
        .parsing-issues.has-errors { border-color: var(--error); }
        .parsing-issues.has-warnings { border-color: var(--warning); }

        /* Debug */
        .debug { background: var(--glass); border: 1px solid var(--glass-border); border-radius: 12px; margin-top: 1.5rem; }
        .debug-header { padding: 1rem; background: var(--bg-tertiary); cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; color: var(--text-secondary); }
        .debug-body { max-height: 0; overflow: hidden; transition: max-height 0.4s; }
        .debug.expanded .debug-body { max-height: 500px; }
        .debug.expanded .expand-icon { transform: rotate(180deg); }
        .debug-log { padding: 1rem; background: var(--bg-secondary); max-height: 300px; overflow-y: auto; }
        .log-entry { font-size: 0.72rem; padding: 0.3rem 0; display: flex; gap: 0.75rem; font-family: 'JetBrains Mono', monospace; }
        .log-time { color: var(--text-dim); }
        .log-type { width: 50px; font-weight: 600; }
        .log-type.info { color: var(--accent); }
        .log-type.error { color: var(--error); }
        .log-type.success { color: var(--success); }
        .log-type.warn { color: var(--warning); }
        .log-msg { color: var(--text-secondary); word-break: break-all; }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 0.75rem 1rem;
            min-width: 200px;
            max-width: 300px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s ease-out, visibility 0.15s ease-out;
            z-index: 9999;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
            pointer-events: auto;
        }
        .tooltip.visible { opacity: 1; visibility: visible; }
        .tooltip-title { font-weight: 600; color: var(--accent); font-size: 0.8rem; margin-bottom: 0.25rem; font-family: 'JetBrains Mono', monospace; }
        .tooltip-desc { color: var(--text-secondary); font-size: 0.72rem; line-height: 1.4; }
        .tooltip-value { margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border); color: var(--text-primary); font-size: 0.68rem; font-family: 'JetBrains Mono', monospace; word-break: break-all; max-height: 60px; overflow-y: auto; }

        /* Toast */
        .toast {
            position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%) translateY(100px);
            background: var(--bg-secondary); border: 1px solid var(--accent); color: var(--text-primary);
            padding: 0.75rem 1.5rem; border-radius: 10px; font-size: 0.85rem; z-index: 9999;
            opacity: 0; transition: all 0.3s; display: flex; align-items: center; gap: 0.5rem;
        }
        .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

        /* Help Modal */
        .help-btn {
            position: absolute;
            top: 0;
            right: 54px;
            width: 44px;
            height: 44px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.25rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .help-btn:hover { border-color: var(--accent); }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }
        .modal-overlay.visible { display: flex; }
        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            background: var(--bg-secondary);
        }
        .modal-title { font-size: 1.1rem; font-weight: 600; display: flex; align-items: center; gap: 0.5rem; }
        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            transition: color 0.2s;
        }
        .modal-close:hover { color: var(--text-primary); }
        .modal-body { padding: 1.5rem; }
        .help-section { margin-bottom: 1.5rem; }
        .help-section:last-child { margin-bottom: 0; }
        .help-section h3 {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .help-section p {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 0.5rem;
        }
        .help-section a {
            color: var(--accent-secondary);
            text-decoration: none;
        }
        .help-section a:hover { text-decoration: underline; }
        .help-list {
            list-style: none;
            padding: 0;
            margin: 0.5rem 0;
        }
        .help-list li {
            font-size: 0.8rem;
            color: var(--text-secondary);
            padding: 0.3rem 0;
            padding-left: 1.2rem;
            position: relative;
        }
        .help-list li::before {
            content: '‚Ä¢';
            position: absolute;
            left: 0;
            color: var(--accent);
        }

        @media (max-width: 640px) {
            .container { padding: 1rem; }
            h1 { font-size: 1.5rem; }
            .summary { flex-direction: column; }
            .theme-toggle { position: static; margin-bottom: 1rem; }
            header { text-align: left; }
        }
    </style>
</head>
<body>
    <div class="tooltip" id="tooltip">
        <div class="tooltip-title" id="tooltipTitle"></div>
        <div class="tooltip-desc" id="tooltipDesc"></div>
        <div class="tooltip-value" id="tooltipValue"></div>
    </div>
    
    <div class="toast" id="toast"><span>‚úì</span><span id="toastMsg">Copied!</span></div>

    <!-- Help Modal -->
    <div class="modal-overlay" id="helpModal" onclick="if(event.target===this)closeHelp()">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">üìö Email Authentication Guide</span>
                <button class="modal-close" onclick="closeHelp()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="help-section">
                    <h3>üîê DKIM (DomainKeys Identified Mail)</h3>
                    <p>DKIM allows senders to cryptographically sign emails, proving the message hasn't been altered in transit. The receiving server fetches the sender's public key from DNS and verifies the signature.</p>
                    <ul class="help-list">
                        <li>Protects against email tampering</li>
                        <li>Verifies the sending domain's identity</li>
                        <li>Uses RSA or Ed25519 cryptographic signatures</li>
                    </ul>
                    <p><a href="https://datatracker.ietf.org/doc/html/rfc6376" target="_blank">RFC 6376 - DKIM Signatures</a></p>
                </div>

                <div class="help-section">
                    <h3>üõ°Ô∏è SPF (Sender Policy Framework)</h3>
                    <p>SPF allows domain owners to specify which mail servers are authorized to send email on their behalf. Receivers check if the sending IP is listed in the domain's SPF record.</p>
                    <ul class="help-list">
                        <li>Prevents unauthorized servers from sending as your domain</li>
                        <li>Uses DNS TXT records to publish authorized IPs</li>
                        <li>Results: pass, fail, softfail, neutral, none</li>
                    </ul>
                    <p><a href="https://datatracker.ietf.org/doc/html/rfc7208" target="_blank">RFC 7208 - SPF</a></p>
                </div>

                <div class="help-section">
                    <h3>üìã DMARC (Domain-based Message Authentication)</h3>
                    <p>DMARC builds on DKIM and SPF, telling receivers what to do when authentication fails. It also enables reporting so domain owners can monitor abuse.</p>
                    <ul class="help-list">
                        <li>Policies: none (monitor), quarantine (spam), reject</li>
                        <li>Requires alignment between From domain and DKIM/SPF domains</li>
                        <li>Enables aggregate and forensic reporting</li>
                    </ul>
                    <p><a href="https://datatracker.ietf.org/doc/html/rfc7489" target="_blank">RFC 7489 - DMARC</a></p>
                </div>

                <div class="help-section">
                    <h3>üîó ARC (Authenticated Received Chain)</h3>
                    <p>ARC preserves email authentication results when messages are forwarded through mailing lists or other intermediaries that may break DKIM signatures.</p>
                    <ul class="help-list">
                        <li>Each intermediary adds a signed ARC set</li>
                        <li>Chain validation shows if previous hops verified</li>
                        <li>Helps legitimate forwarded mail pass authentication</li>
                    </ul>
                    <p><a href="https://datatracker.ietf.org/doc/html/rfc8617" target="_blank">RFC 8617 - ARC</a></p>
                </div>

                <div class="help-section">
                    <h3>‚ö†Ô∏è Security Considerations</h3>
                    <ul class="help-list">
                        <li><strong>l= tag:</strong> Limits signed body bytes - unsigned content can be appended</li>
                        <li><strong>x= tag:</strong> Signature expiration - expired signatures should be treated with caution</li>
                        <li><strong>Alignment:</strong> DMARC requires DKIM/SPF domains to match the From header</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <header>
            <button class="help-btn" onclick="openHelp()" title="Help">‚ùì</button>
            <button class="theme-toggle" onclick="toggleTheme()" id="themeBtn">üåô</button>
            <div class="logo">
                <div class="logo-icon">üîê</div>
                <div>
                    <h1>DKIM Validator</h1>
                    <p class="subtitle">RFC 6376 Cryptographic Signature Verification</p>
                </div>
            </div>
            <p class="privacy">100% client-side ¬∑ No data sent to servers ¬∑ DNS queries only for public key retrieval</p>
        </header>

        <div class="input-section">
            <label class="input-label">üìß Raw Email Headers & Body</label>
            <textarea id="input" placeholder="Paste raw email content here..."></textarea>
            <div class="input-footer">
                <button class="btn" onclick="clearAll()">üóëÔ∏è Clear</button>
                <span class="status" id="status"></span>
            </div>
        </div>

        <div class="results" id="results">
            <div id="parsingIssuesEl"></div>
            <div id="headersEl"></div>
            <div class="summary" id="summaryEl"></div>
            <div id="relayEl"></div>
            <div id="spfEl"></div>
            <div id="dmarcEl"></div>
            <div id="arcEl"></div>
            <div id="sigsEl"></div>
            <div class="debug" id="debugEl">
                <div class="debug-header" onclick="this.parentElement.classList.toggle('expanded')">
                    <span>üîç Debug Log</span>
                    <span class="expand-icon">‚ñº</span>
                </div>
                <div class="debug-body">
                    <div class="debug-log" id="debugLog"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // Tag descriptions with RFC references
    const DKIM_TAGS = {
        v: { name: 'Version', desc: 'DKIM signature version (must be "1") [RFC 6376 ¬ß3.5]' },
        a: { name: 'Algorithm', desc: 'Signing algorithm: rsa-sha256 or rsa-sha1 [RFC 6376 ¬ß3.5]' },
        b: { name: 'Signature', desc: 'Base64-encoded cryptographic signature [RFC 6376 ¬ß3.5]' },
        bh: { name: 'Body Hash', desc: 'Hash of canonicalized message body [RFC 6376 ¬ß3.5]' },
        c: { name: 'Canonicalization', desc: 'Header/body normalization: simple or relaxed [RFC 6376 ¬ß3.4]' },
        d: { name: 'Domain', desc: 'Signing domain identifier (SDID) [RFC 6376 ¬ß3.5]' },
        s: { name: 'Selector', desc: 'DNS selector for public key lookup [RFC 6376 ¬ß3.5]' },
        h: { name: 'Signed Headers', desc: 'Headers included in signature [RFC 6376 ¬ß3.5]' },
        t: { name: 'Timestamp', desc: 'Signature creation time (Unix epoch) [RFC 6376 ¬ß3.5]' },
        x: { name: 'Expiration', desc: 'Signature expiration time (Unix epoch) [RFC 6376 ¬ß3.5]' },
        l: { name: 'Body Length', desc: 'Number of body bytes signed (security risk!) [RFC 6376 ¬ß3.5]' },
        i: { name: 'Identity', desc: 'Agent/user identifier (AUID) [RFC 6376 ¬ß3.5]' }
    };

    const DNS_TAGS = {
        v: { name: 'Version', desc: 'DKIM key record version (must be "DKIM1") [RFC 6376 ¬ß3.6.1]' },
        k: { name: 'Key Type', desc: 'Type of key: rsa (default) or ed25519 [RFC 6376 ¬ß3.6.1]' },
        p: { name: 'Public Key', desc: 'Base64-encoded public key data [RFC 6376 ¬ß3.6.1]' },
        h: { name: 'Hash Algorithms', desc: 'Acceptable hash algorithms [RFC 6376 ¬ß3.6.1]' },
        t: { name: 'Flags', desc: 'Flags: y=testing mode, s=strict [RFC 6376 ¬ß3.6.1]' }
    };

    const SPF_MECHANISMS = {
        all: { name: 'All', desc: 'Matches all senders (catchall) [RFC 7208 ¬ß5.1]' },
        ip4: { name: 'IPv4', desc: 'Match if sender IP is in this IPv4 range [RFC 7208 ¬ß5.6]' },
        ip6: { name: 'IPv6', desc: 'Match if sender IP is in this IPv6 range [RFC 7208 ¬ß5.6]' },
        a: { name: 'A Record', desc: 'Match if sender IP matches domain A record [RFC 7208 ¬ß5.3]' },
        mx: { name: 'MX Record', desc: 'Match if sender IP matches domain MX hosts [RFC 7208 ¬ß5.4]' },
        include: { name: 'Include', desc: 'Include SPF policy from another domain [RFC 7208 ¬ß5.2]' },
        redirect: { name: 'Redirect', desc: 'Use SPF policy from another domain instead [RFC 7208 ¬ß6.1]' },
        exists: { name: 'Exists', desc: 'Match if domain exists (has any A record) [RFC 7208 ¬ß5.7]' },
        ptr: { name: 'PTR', desc: 'Match via reverse DNS (deprecated) [RFC 7208 ¬ß5.5]' }
    };

    const SPF_QUALIFIERS = {
        '+': { name: 'Pass', desc: 'IP is authorized', color: 'success' },
        '-': { name: 'Fail', desc: 'IP is not authorized', color: 'error' },
        '~': { name: 'SoftFail', desc: 'IP is probably not authorized', color: 'warning' },
        '?': { name: 'Neutral', desc: 'No assertion about IP', color: 'neutral' }
    };

    const SPF_RESULTS = {
        pass: { name: 'Pass', desc: 'Sender IP is authorized', color: 'success', icon: '‚úì' },
        fail: { name: 'Fail', desc: 'Sender IP is NOT authorized', color: 'error', icon: '‚úó' },
        softfail: { name: 'SoftFail', desc: 'Sender IP is probably not authorized', color: 'warning', icon: '~' },
        neutral: { name: 'Neutral', desc: 'No assertion about sender IP', color: 'neutral', icon: '?' },
        none: { name: 'None', desc: 'No SPF record found', color: 'neutral', icon: '‚àí' },
        permerror: { name: 'PermError', desc: 'Permanent error in SPF evaluation', color: 'error', icon: '!' },
        temperror: { name: 'TempError', desc: 'Temporary error (DNS timeout)', color: 'warning', icon: '‚ö†' }
    };

    const DMARC_TAGS = {
        v: { name: 'Version', desc: 'DMARC version (must be "DMARC1") [RFC 7489 ¬ß6.3]' },
        p: { name: 'Policy', desc: 'Policy for the domain: none, quarantine, reject [RFC 7489 ¬ß6.3]' },
        sp: { name: 'Subdomain Policy', desc: 'Policy for subdomains (defaults to p=) [RFC 7489 ¬ß6.3]' },
        pct: { name: 'Percentage', desc: 'Percentage of messages to apply policy (default: 100) [RFC 7489 ¬ß6.3]' },
        rua: { name: 'Aggregate Reports', desc: 'URI(s) for aggregate reports [RFC 7489 ¬ß6.3]' },
        ruf: { name: 'Forensic Reports', desc: 'URI(s) for forensic/failure reports [RFC 7489 ¬ß6.3]' },
        adkim: { name: 'DKIM Alignment', desc: 'DKIM alignment mode: r=relaxed, s=strict [RFC 7489 ¬ß6.3]' },
        aspf: { name: 'SPF Alignment', desc: 'SPF alignment mode: r=relaxed, s=strict [RFC 7489 ¬ß6.3]' },
        fo: { name: 'Failure Options', desc: 'When to generate failure reports: 0, 1, d, s [RFC 7489 ¬ß6.3]' },
        rf: { name: 'Report Format', desc: 'Format for failure reports (afrf) [RFC 7489 ¬ß6.3]' },
        ri: { name: 'Report Interval', desc: 'Interval between aggregate reports in seconds [RFC 7489 ¬ß6.3]' }
    };

    const DMARC_POLICIES = {
        none: { name: 'None', desc: 'No action taken, monitor only [RFC 7489 ¬ß6.3]', color: 'warning', icon: '?' },
        quarantine: { name: 'Quarantine', desc: 'Treat as suspicious (spam folder) [RFC 7489 ¬ß6.3]', color: 'warning', icon: '‚ö†' },
        reject: { name: 'Reject', desc: 'Reject the message outright [RFC 7489 ¬ß6.3]', color: 'success', icon: '‚úì' }
    };

    // ARC (Authenticated Received Chain) tags - RFC 8617
    const ARC_SEAL_TAGS = {
        i: { name: 'Instance', desc: 'ARC chain instance number (1, 2, 3...) [RFC 8617 ¬ß4.1]' },
        a: { name: 'Algorithm', desc: 'Signing algorithm (rsa-sha256) [RFC 8617 ¬ß4.1]' },
        b: { name: 'Signature', desc: 'Base64-encoded signature of ARC headers [RFC 8617 ¬ß4.1]' },
        cv: { name: 'Chain Validation', desc: 'Validation status: none, fail, pass [RFC 8617 ¬ß4.1]' },
        d: { name: 'Domain', desc: 'Signing domain [RFC 8617 ¬ß4.1]' },
        s: { name: 'Selector', desc: 'DNS selector for public key [RFC 8617 ¬ß4.1]' },
        t: { name: 'Timestamp', desc: 'Signature creation time (Unix epoch) [RFC 8617 ¬ß4.1]' }
    };

    const ARC_MESSAGE_TAGS = {
        i: { name: 'Instance', desc: 'ARC chain instance number [RFC 8617 ¬ß4.1]' },
        a: { name: 'Algorithm', desc: 'Signing algorithm [RFC 8617 ¬ß4.1]' },
        b: { name: 'Signature', desc: 'Base64-encoded signature [RFC 8617 ¬ß4.1]' },
        bh: { name: 'Body Hash', desc: 'Hash of canonicalized body [RFC 8617 ¬ß4.1]' },
        c: { name: 'Canonicalization', desc: 'Header/body normalization method [RFC 8617 ¬ß4.1]' },
        d: { name: 'Domain', desc: 'Signing domain [RFC 8617 ¬ß4.1]' },
        h: { name: 'Signed Headers', desc: 'Headers included in signature [RFC 8617 ¬ß4.1]' },
        s: { name: 'Selector', desc: 'DNS selector for public key [RFC 8617 ¬ß4.1]' },
        t: { name: 'Timestamp', desc: 'Signature creation time [RFC 8617 ¬ß4.1]' }
    };

    const ARC_AUTH_TAGS = {
        i: { name: 'Instance', desc: 'ARC chain instance number [RFC 8617 ¬ß4.1]' },
        dkim: { name: 'DKIM Result', desc: 'DKIM authentication result [RFC 8617 ¬ß4.1]' },
        spf: { name: 'SPF Result', desc: 'SPF authentication result [RFC 8617 ¬ß4.1]' },
        dmarc: { name: 'DMARC Result', desc: 'DMARC authentication result [RFC 8617 ¬ß4.1]' },
        arc: { name: 'ARC Result', desc: 'Previous ARC validation result [RFC 8617 ¬ß4.1]' }
    };

    const ARC_CV_STATUS = {
        none: { name: 'None', desc: 'No previous ARC sets in chain [RFC 8617 ¬ß4.1]', color: 'neutral', icon: '‚àí' },
        pass: { name: 'Pass', desc: 'Previous ARC sets validated successfully [RFC 8617 ¬ß4.1]', color: 'success', icon: '‚úì' },
        fail: { name: 'Fail', desc: 'Previous ARC set validation failed [RFC 8617 ¬ß4.1]', color: 'error', icon: '‚úó' }
    };

    // State
    const logs = [];
    let validateTimeout;

    // Theme
    function toggleTheme() {
        const html = document.documentElement;
        const btn = document.getElementById('themeBtn');
        const isDark = html.dataset.theme === 'dark';
        html.dataset.theme = isDark ? 'light' : 'dark';
        btn.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
        localStorage.setItem('theme', html.dataset.theme);
    }
    
    (function initTheme() {
        const saved = localStorage.getItem('theme');
        if (saved) {
            document.documentElement.dataset.theme = saved;
            document.getElementById('themeBtn').textContent = saved === 'dark' ? 'üåô' : '‚òÄÔ∏è';
        }
    })();

    // Help modal
    function openHelp() {
        document.getElementById('helpModal').classList.add('visible');
        document.body.style.overflow = 'hidden';
    }
    function closeHelp() {
        document.getElementById('helpModal').classList.remove('visible');
        document.body.style.overflow = '';
    }
    // Close on Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && document.getElementById('helpModal').classList.contains('visible')) {
            closeHelp();
        }
    });

    // Utils
    function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
    function log(type, msg) { logs.push({ time: new Date().toISOString().split('T')[1].split('.')[0], type, msg }); }
    function showToast(msg) {
        const t = document.getElementById('toast');
        document.getElementById('toastMsg').textContent = msg;
        t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 2000);
    }
    function copy(btn, val) {
        navigator.clipboard.writeText(val);
        btn.classList.add('copied');
        const orig = btn.textContent;
        btn.textContent = '‚úì';
        setTimeout(() => { btn.classList.remove('copied'); btn.textContent = orig; }, 1500);
        showToast('Copied!');
    }

    // Clear
    function clearAll() {
        document.getElementById('input').value = '';
        document.getElementById('results').classList.remove('visible');
        document.getElementById('status').innerHTML = '';
    }

    // Auto-validate
    document.getElementById('input').addEventListener('input', () => {
        clearTimeout(validateTimeout);
        const val = document.getElementById('input').value.trim();
        if (!val || val.length < 50) {
            document.getElementById('results').classList.remove('visible');
            document.getElementById('status').innerHTML = '';
            return;
        }
        document.getElementById('status').innerHTML = '<div class="spinner"></div> Validating...';
        validateTimeout = setTimeout(validate, 400);
    });

    // Tooltip Manager
    const Tooltip = {
        el: null,
        hideTimer: null,
        activeTag: null,

        init() {
            this.el = document.getElementById('tooltip');
            // Keep tooltip open when hovering over it
            this.el.addEventListener('mouseenter', () => this.cancelHide());
            this.el.addEventListener('mouseleave', () => this.scheduleHide());
        },

        show(tag) {
            this.cancelHide();
            this.activeTag = tag;

            const { tag: name, tagName, tagDesc, tagValue } = tag.dataset;
            document.getElementById('tooltipTitle').textContent =
                tag.classList.contains('header') ? tagName : `${tagName} (${name}=)`;
            document.getElementById('tooltipDesc').textContent = tagDesc;
            document.getElementById('tooltipValue').textContent = tagValue;

            // Position tooltip
            const r = tag.getBoundingClientRect();
            let left = r.left;
            let top = r.bottom + 10;

            // Adjust if overflowing right
            if (left + 300 > window.innerWidth) {
                left = window.innerWidth - 320;
            }
            if (left < 10) left = 10;

            // Adjust if overflowing bottom
            if (top + 150 > window.innerHeight) {
                top = r.top - 160;
            }

            this.el.style.left = left + 'px';
            this.el.style.top = top + 'px';
            this.el.classList.add('visible');
        },

        hide() {
            this.el.classList.remove('visible');
            this.activeTag = null;
        },

        cancelHide() {
            if (this.hideTimer) {
                clearTimeout(this.hideTimer);
                this.hideTimer = null;
            }
        },

        scheduleHide() {
            this.cancelHide();
            this.hideTimer = setTimeout(() => this.hide(), 250);
        },

        // Attach events to a tag element
        attachToTag(tag) {
            tag.addEventListener('mouseenter', (e) => {
                if (!e.target.closest('.copy-btn')) {
                    this.show(tag);
                }
            });
            tag.addEventListener('mouseleave', () => {
                this.scheduleHide();
            });
        }
    };

    Tooltip.init();

    // Toggle card
    function toggleCard(el) { el.closest('.sig-card').classList.toggle('expanded'); }

    // Parse email
    function parseEmail(raw) {
        const errors = [];
        const warnings = [];

        // Check for common issues
        if (!raw || raw.trim().length === 0) {
            errors.push({ type: 'empty', message: 'No email content provided', suggestion: 'Paste the raw email source including headers and body' });
            return { headers: [], body: '', dkimSigs: [], errors, warnings };
        }

        // Check if it looks like just a body (no headers)
        if (!raw.includes(':') || raw.indexOf(':') > 100) {
            errors.push({ type: 'no_headers', message: 'No email headers detected', suggestion: 'Make sure to include the full raw email source, not just the body. In most email clients, look for "Show Original" or "View Source"' });
        }

        // Try to find header/body separator
        let headerSection, body;
        let idx = raw.indexOf('\r\n\r\n');
        if (idx !== -1) {
            headerSection = raw.slice(0, idx);
            body = raw.slice(idx + 4);
        } else {
            idx = raw.indexOf('\n\n');
            if (idx !== -1) {
                headerSection = raw.slice(0, idx);
                body = raw.slice(idx + 2);
            } else {
                // No clear separator found - treat entire content as headers
                headerSection = raw;
                body = '';
                warnings.push({ type: 'no_body', message: 'No message body found', suggestion: 'The email appears to have no body section. This may be normal for some emails, or the header/body separator (blank line) may be missing' });
            }
        }

        // Normalize to \r\n for consistent processing
        headerSection = headerSection.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n/g, '\r\n');
        const headers = [];
        let cur = null;
        let invalidLines = 0;

        for (const line of headerSection.split('\r\n')) {
            if (/^[ \t]/.test(line) && cur) {
                cur.raw += '\r\n' + line;
                cur.value += '\r\n' + line;
            } else {
                if (cur) headers.push({ name: cur.name, value: cur.value, raw: cur.raw });
                const i = line.indexOf(':');
                if (i > 0) {
                    cur = {
                        name: line.slice(0, i),
                        value: line.slice(i + 1),
                        raw: line
                    };
                } else if (line.trim().length > 0) {
                    invalidLines++;
                    cur = null;
                } else {
                    cur = null;
                }
            }
        }
        if (cur) headers.push({ name: cur.name, value: cur.value, raw: cur.raw });

        if (invalidLines > 3) {
            warnings.push({ type: 'malformed_headers', message: `Found ${invalidLines} lines that don't look like headers`, suggestion: 'Some header lines may be malformed. Ensure you\'re pasting the raw email source without modifications' });
        }

        // Check for essential headers
        const headerNames = headers.map(h => h.name.toLowerCase());
        if (!headerNames.includes('from')) {
            warnings.push({ type: 'missing_from', message: 'No "From" header found', suggestion: 'The From header is required in valid emails. The email may be truncated or malformed' });
        }
        if (!headerNames.includes('date')) {
            warnings.push({ type: 'missing_date', message: 'No "Date" header found', suggestion: 'Most emails have a Date header. The email may be incomplete' });
        }

        // Check if input looks like it might be HTML encoded
        if (raw.includes('&lt;') || raw.includes('&gt;') || raw.includes('&amp;')) {
            warnings.push({ type: 'html_encoded', message: 'Content appears to be HTML-encoded', suggestion: 'The email may have been copied from an HTML view. Try using "View Source" or "Show Original" in your email client' });
        }

        // Check for base64-encoded content that might be the whole email
        if (/^[A-Za-z0-9+/=\s]+$/.test(raw.trim()) && raw.length > 200) {
            warnings.push({ type: 'possibly_base64', message: 'Content looks like base64-encoded data', suggestion: 'This might be an encoded attachment rather than the email source. Look for "Show Original" to get the raw headers' });
        }

        const dkimSigs = headers.filter(h => h.name.toLowerCase() === 'dkim-signature').map(h => ({
            raw: h.raw,
            parsed: parseDkimTags(h.raw)
        }));

        return { headers, body, dkimSigs, errors, warnings };
    }

    function parseDkimTags(raw) {
        const unfolded = raw.replace(/\r?\n[ \t]+/g, ' ');
        const match = unfolded.match(/DKIM-Signature:\s*(.+)/i);
        if (!match) return null;
        const tags = {};
        const re = /([a-z]+)\s*=\s*([^;]+)/gi;
        let m;
        while ((m = re.exec(match[1]))) {
            let val = m[2].trim();
            if (m[1] === 'b' || m[1] === 'bh') val = val.replace(/\s+/g, '');
            tags[m[1].toLowerCase()] = val;
        }
        return tags;
    }

    function parseDnsTags(record) {
        const tags = {};
        const re = /([a-z]+)\s*=\s*([^;]+)/gi;
        let m;
        while ((m = re.exec(record))) {
            let val = m[2].trim();
            // Remove whitespace from base64-encoded values (p=public key)
            if (m[1].toLowerCase() === 'p') {
                val = val.replace(/\s+/g, '');
            }
            tags[m[1].toLowerCase()] = val;
        }
        return tags;
    }

    // Canonicalization
    function canonHeaderRelaxed(name, value) {
        let v = value.replace(/\r?\n[ \t]+/g, ' ').replace(/[ \t]+/g, ' ').trim();
        return name.toLowerCase() + ':' + v;
    }

    function canonBodyRelaxed(body) {
        if (!body) return '\r\n';
        let c = body.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n/g, '\r\n');
        c = c.split('\r\n').map(l => l.replace(/[ \t]+/g, ' ').replace(/ +$/, '')).join('\r\n');
        c = c.replace(/(\r\n)+$/, '') || '';
        return c + '\r\n';
    }

    function canonBodySimple(body) {
        if (!body) return '\r\n';
        let c = body.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n/g, '\r\n');
        c = c.replace(/(\r\n)+$/, '') || '';
        return c + '\r\n';
    }

    // Extract domain from Return-Path or From header
    function extractMailDomain(headers) {
        // Try Return-Path first (envelope sender)
        const returnPath = headers.find(h => h.name.toLowerCase() === 'return-path');
        if (returnPath) {
            const match = returnPath.value.match(/<([^>]+)>|([^\s<>]+@[^\s<>]+)/);
            if (match) {
                const email = match[1] || match[2];
                const domain = email.split('@')[1];
                if (domain) return domain.toLowerCase().trim();
            }
        }
        // Fall back to From header
        const from = headers.find(h => h.name.toLowerCase() === 'from');
        if (from) {
            const match = from.value.match(/<([^>]+)>|([^\s<>]+@[^\s<>]+)/);
            if (match) {
                const email = match[1] || match[2];
                const domain = email.split('@')[1];
                if (domain) return domain.toLowerCase().trim();
            }
        }
        return null;
    }

    // Extract sender IP from Received headers
    function extractSenderIP(headers) {
        // Look for the first "Received:" header (bottom-most in chain = first hop)
        // Parse patterns like "from mail.example.com ([192.168.1.1])" or "from [192.168.1.1]"
        const receivedHeaders = headers.filter(h => h.name.toLowerCase() === 'received');

        // The last Received header is typically the first hop (closest to sender)
        for (let i = receivedHeaders.length - 1; i >= 0; i--) {
            const val = receivedHeaders[i].value;

            // Match IPv4 in brackets: [192.168.1.1]
            let match = val.match(/\[(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\]/);
            if (match && !isPrivateIP(match[1])) {
                log('info', `Extracted sender IP: ${match[1]} from Received header`);
                return { ip: match[1], version: 4 };
            }

            // Match IPv4 in parentheses: (192.168.1.1)
            match = val.match(/\((\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\)/);
            if (match && !isPrivateIP(match[1])) {
                log('info', `Extracted sender IP: ${match[1]} from Received header`);
                return { ip: match[1], version: 4 };
            }

            // Match "from ... by" pattern with IP
            match = val.match(/from\s+\S+\s+\((?:[^)]*\s)?(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/i);
            if (match && !isPrivateIP(match[1])) {
                log('info', `Extracted sender IP: ${match[1]} from Received header`);
                return { ip: match[1], version: 4 };
            }

            // Match IPv6 in brackets: [2001:db8::1]
            match = val.match(/\[([0-9a-fA-F:]+:[0-9a-fA-F:]+)\]/);
            if (match && match[1].includes(':')) {
                log('info', `Extracted sender IPv6: ${match[1]} from Received header`);
                return { ip: match[1], version: 6 };
            }
        }

        log('warn', 'Could not extract sender IP from Received headers');
        return null;
    }

    function isPrivateIP(ip) {
        const parts = ip.split('.').map(Number);
        if (parts.length !== 4) return false;
        // 10.0.0.0/8
        if (parts[0] === 10) return true;
        // 172.16.0.0/12
        if (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) return true;
        // 192.168.0.0/16
        if (parts[0] === 192 && parts[1] === 168) return true;
        // 127.0.0.0/8
        if (parts[0] === 127) return true;
        return false;
    }

    // Parse email relay chain from Received headers
    function parseRelayChain(headers) {
        const receivedHeaders = headers.filter(h => h.name.toLowerCase() === 'received');
        const hops = [];

        for (const hdr of receivedHeaders) {
            const val = hdr.value.replace(/\r?\n[ \t]+/g, ' ');
            const hop = { raw: val };

            // Parse "from <server>" pattern
            const fromMatch = val.match(/from\s+([^\s(]+)/i);
            if (fromMatch) hop.from = fromMatch[1];

            // Parse "by <server>" pattern
            const byMatch = val.match(/by\s+([^\s(]+)/i);
            if (byMatch) hop.by = byMatch[1];

            // Parse IP addresses
            const ipMatch = val.match(/\[(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\]/);
            if (ipMatch) hop.ip = ipMatch[1];

            // Parse IPv6
            const ipv6Match = val.match(/\[([0-9a-fA-F:]+:[0-9a-fA-F:]+)\]/);
            if (ipv6Match && ipv6Match[1].includes(':')) hop.ip = ipv6Match[1];

            // Parse timestamp - look for various date patterns
            // Common format: ; Mon, 27 Jan 2025 10:30:45 +0000
            const dateMatch = val.match(/;\s*([A-Za-z]{3},\s+\d{1,2}\s+[A-Za-z]{3}\s+\d{4}\s+\d{2}:\d{2}:\d{2}\s*[+-]?\d{0,4})/);
            if (dateMatch) {
                try {
                    hop.timestamp = new Date(dateMatch[1]);
                    if (isNaN(hop.timestamp.getTime())) hop.timestamp = null;
                } catch { hop.timestamp = null; }
            }

            // Alternative timestamp format
            if (!hop.timestamp) {
                const altDateMatch = val.match(/(\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2})/);
                if (altDateMatch) {
                    try {
                        hop.timestamp = new Date(altDateMatch[1]);
                        if (isNaN(hop.timestamp.getTime())) hop.timestamp = null;
                    } catch { hop.timestamp = null; }
                }
            }

            // Parse protocol (SMTP, ESMTP, ESMTPS, etc.)
            const protoMatch = val.match(/with\s+(E?SMTPS?A?)/i);
            if (protoMatch) hop.protocol = protoMatch[1].toUpperCase();

            // Parse TLS info
            if (val.match(/\(.*TLS.*\)/i) || val.match(/ESMTPS/i)) hop.tls = true;

            hops.push(hop);
        }

        // Received headers are in reverse order (newest first), reverse for chronological
        hops.reverse();

        // Calculate latencies between hops
        for (let i = 1; i < hops.length; i++) {
            if (hops[i].timestamp && hops[i-1].timestamp) {
                hops[i].latency = hops[i].timestamp.getTime() - hops[i-1].timestamp.getTime();
            }
        }

        return hops;
    }

    function formatLatency(ms) {
        if (ms === undefined || ms === null) return null;
        if (ms < 0) ms = 0; // Negative latencies due to clock skew
        if (ms < 1000) return `${ms}ms`;
        if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
        if (ms < 3600000) return `${(ms / 60000).toFixed(1)}m`;
        return `${(ms / 3600000).toFixed(1)}h`;
    }

    function getLatencyClass(ms) {
        if (ms === undefined || ms === null) return '';
        if (ms < 1000) return 'fast';
        if (ms < 10000) return 'medium';
        return 'slow';
    }

    function renderRelayChain(hops) {
        if (!hops || hops.length === 0) {
            return '<div class="error-msg">No Received headers found to trace email path</div>';
        }

        // Calculate total transit time
        let totalLatency = 0;
        let validLatencies = 0;
        for (const hop of hops) {
            if (hop.latency && hop.latency > 0) {
                totalLatency += hop.latency;
                validLatencies++;
            }
        }

        const summaryHtml = `
            <div class="relay-summary-row">
                <div class="relay-stat">
                    <span>Hops:</span>
                    <span class="relay-stat-value">${hops.length}</span>
                </div>
                ${totalLatency > 0 ? `<div class="relay-stat">
                    <span>Total Transit:</span>
                    <span class="relay-stat-value">${formatLatency(totalLatency)}</span>
                </div>` : ''}
                ${validLatencies > 0 ? `<div class="relay-stat">
                    <span>Avg per Hop:</span>
                    <span class="relay-stat-value">${formatLatency(Math.round(totalLatency / validLatencies))}</span>
                </div>` : ''}
            </div>
        `;

        const hopsHtml = hops.map((hop, i) => {
            const isOrigin = i === 0;
            const server = hop.by || hop.from || 'Unknown server';
            const timeStr = hop.timestamp ? hop.timestamp.toLocaleString() : '';
            const latencyHtml = hop.latency !== undefined ?
                `<span class="relay-latency ${getLatencyClass(hop.latency)}">+${formatLatency(hop.latency)}</span>` : '';

            return `
                <div class="relay-hop ${isOrigin ? 'origin' : ''}">
                    <div class="relay-hop-header">
                        <span class="relay-hop-server">${esc(server)}</span>
                        <span class="relay-hop-time">${esc(timeStr)} ${latencyHtml}</span>
                    </div>
                    <div class="relay-hop-details">
                        ${hop.from ? `<span class="relay-hop-detail">from <span>${esc(hop.from)}</span></span>` : ''}
                        ${hop.ip ? `<span class="relay-hop-detail">IP <span>${esc(hop.ip)}</span></span>` : ''}
                        ${hop.protocol ? `<span class="relay-hop-detail">via <span>${esc(hop.protocol)}</span></span>` : ''}
                        ${hop.tls ? `<span class="relay-hop-detail" style="color:var(--success)">TLS</span>` : ''}
                    </div>
                </div>
            `;
        }).join('');

        return `
            <div class="relay-card expanded">
                <div class="sig-header" onclick="toggleCard(this)">
                    <div class="sig-title">
                        <span class="sig-num">üì¨</span>
                        <span class="sig-domain">Email Relay Path</span>
                        <span class="badge" style="background:rgba(0,212,255,0.15);color:var(--accent-secondary)">${hops.length} HOPS</span>
                    </div>
                    <span class="expand-icon">‚ñº</span>
                </div>
                <div class="sig-content">
                    <div class="sig-body">
                        ${summaryHtml}
                        <div class="sig-section">
                            <div class="sig-section-title">üì° Relay Timeline</div>
                            <div class="relay-timeline">${hopsHtml}</div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    // IPv4 CIDR matching
    function ipv4ToInt(ip) {
        const parts = ip.split('.').map(Number);
        return ((parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8) | parts[3]) >>> 0;
    }

    function ipv4MatchesCIDR(ip, cidr) {
        let [network, prefixStr] = cidr.split('/');
        const prefix = prefixStr ? parseInt(prefixStr, 10) : 32;

        const ipInt = ipv4ToInt(ip);
        const networkInt = ipv4ToInt(network);
        const mask = prefix === 0 ? 0 : (~0 << (32 - prefix)) >>> 0;

        return (ipInt & mask) === (networkInt & mask);
    }

    // IPv6 matching (simplified)
    function expandIPv6(ip) {
        // Handle :: expansion
        let parts = ip.split(':');
        const emptyIndex = parts.indexOf('');

        if (emptyIndex !== -1) {
            const before = parts.slice(0, emptyIndex).filter(p => p);
            const after = parts.slice(emptyIndex + 1).filter(p => p);
            const missing = 8 - before.length - after.length;
            parts = [...before, ...Array(missing).fill('0'), ...after];
        }

        return parts.map(p => p.padStart(4, '0')).join(':');
    }

    function ipv6ToBigInt(ip) {
        const expanded = expandIPv6(ip);
        const hex = expanded.replace(/:/g, '');
        return BigInt('0x' + hex);
    }

    function ipv6MatchesCIDR(ip, cidr) {
        let [network, prefixStr] = cidr.split('/');
        const prefix = prefixStr ? parseInt(prefixStr, 10) : 128;

        const ipBig = ipv6ToBigInt(ip);
        const networkBig = ipv6ToBigInt(network);
        const mask = prefix === 0 ? 0n : (~0n << BigInt(128 - prefix));

        return (ipBig & mask) === (networkBig & mask);
    }

    // DNS lookups for SPF
    async function fetchARecords(domain) {
        try {
            const res = await fetch(`https://cloudflare-dns.com/dns-query?name=${encodeURIComponent(domain)}&type=A`, {
                headers: { Accept: 'application/dns-json' }
            });
            const data = await res.json();
            const ips = [];
            if (data.Answer) {
                for (const a of data.Answer) {
                    if (a.type === 1) ips.push(a.data);
                }
            }
            return ips;
        } catch (e) {
            log('error', `A record lookup failed for ${domain}: ${e.message}`);
            return [];
        }
    }

    async function fetchAAAARecords(domain) {
        try {
            const res = await fetch(`https://cloudflare-dns.com/dns-query?name=${encodeURIComponent(domain)}&type=AAAA`, {
                headers: { Accept: 'application/dns-json' }
            });
            const data = await res.json();
            const ips = [];
            if (data.Answer) {
                for (const a of data.Answer) {
                    if (a.type === 28) ips.push(a.data);
                }
            }
            return ips;
        } catch (e) {
            log('error', `AAAA record lookup failed for ${domain}: ${e.message}`);
            return [];
        }
    }

    async function fetchMXRecords(domain) {
        try {
            const res = await fetch(`https://cloudflare-dns.com/dns-query?name=${encodeURIComponent(domain)}&type=MX`, {
                headers: { Accept: 'application/dns-json' }
            });
            const data = await res.json();
            const hosts = [];
            if (data.Answer) {
                for (const a of data.Answer) {
                    if (a.type === 15) {
                        // MX data format: "priority hostname."
                        const parts = a.data.split(' ');
                        if (parts.length >= 2) {
                            hosts.push(parts[1].replace(/\.$/, ''));
                        }
                    }
                }
            }
            return hosts;
        } catch (e) {
            log('error', `MX record lookup failed for ${domain}: ${e.message}`);
            return [];
        }
    }

    // Full SPF evaluation
    async function evaluateSpf(senderIP, domain, depth = 0, lookupCount = { count: 0 }, trace = null) {
        const MAX_DEPTH = 10;
        const MAX_LOOKUPS = 10;

        // Initialize trace at top level
        if (trace === null) {
            trace = { domains: [], matchPath: [] };
        }

        // Track this domain in the trace
        const domainTrace = {
            domain,
            depth,
            record: null,
            mechanisms: [],
            matched: null
        };
        trace.domains.push(domainTrace);

        if (depth > MAX_DEPTH) {
            log('error', `SPF evaluation exceeded max depth (${MAX_DEPTH})`);
            return { result: 'permerror', reason: 'Too many nested includes', lookups: lookupCount.count, trace };
        }

        if (lookupCount.count >= MAX_LOOKUPS) {
            log('error', `SPF evaluation exceeded max DNS lookups (${MAX_LOOKUPS})`);
            return { result: 'permerror', reason: 'Too many DNS lookups', lookups: lookupCount.count, trace };
        }

        log('info', `Evaluating SPF for ${domain} (depth=${depth}, lookups=${lookupCount.count})`);

        // Fetch SPF record
        const spfResult = await fetchSpfRecord(domain);
        if (!spfResult.ok) {
            domainTrace.error = spfResult.error;
            return { result: 'none', reason: spfResult.error, lookups: lookupCount.count, record: null, trace };
        }

        domainTrace.record = spfResult.record;
        const mechanisms = parseSpfRecord(spfResult.record);
        const ipVersion = senderIP.version;
        const ip = senderIP.ip;

        for (const mech of mechanisms) {
            let matched = false;
            let mechTrace = { mechanism: mech.raw, type: mech.mechanism, qualifier: mech.qualifier, matched: false, details: null };
            domainTrace.mechanisms.push(mechTrace);

            switch (mech.mechanism) {
                case 'all':
                    matched = true;
                    mechTrace.details = 'Matches all';
                    break;

                case 'ip4':
                    if (ipVersion === 4) {
                        matched = ipv4MatchesCIDR(ip, mech.value);
                        mechTrace.details = `Checking ${ip} against ${mech.value}`;
                    } else {
                        mechTrace.details = 'Skipped (sender is IPv6)';
                    }
                    break;

                case 'ip6':
                    if (ipVersion === 6) {
                        matched = ipv6MatchesCIDR(ip, mech.value);
                        mechTrace.details = `Checking ${ip} against ${mech.value}`;
                    } else {
                        mechTrace.details = 'Skipped (sender is IPv4)';
                    }
                    break;

                case 'a':
                    lookupCount.count++;
                    if (lookupCount.count > MAX_LOOKUPS) {
                        return { result: 'permerror', reason: 'Too many DNS lookups', lookups: lookupCount.count, trace };
                    }
                    const aDomain = mech.value || domain;
                    const aRecords = ipVersion === 4 ? await fetchARecords(aDomain) : await fetchAAAARecords(aDomain);
                    mechTrace.details = `${aDomain} ‚Üí ${aRecords.join(', ') || 'none'}`;
                    log('info', `SPF 'a' mechanism: ${aDomain} resolved to ${aRecords.join(', ') || 'none'}`);
                    for (const aIP of aRecords) {
                        if (ipVersion === 4 && ipv4MatchesCIDR(ip, aIP + '/32')) {
                            matched = true;
                            break;
                        } else if (ipVersion === 6 && ipv6MatchesCIDR(ip, aIP + '/128')) {
                            matched = true;
                            break;
                        }
                    }
                    break;

                case 'mx':
                    lookupCount.count++;
                    if (lookupCount.count > MAX_LOOKUPS) {
                        return { result: 'permerror', reason: 'Too many DNS lookups', lookups: lookupCount.count, trace };
                    }
                    const mxDomain = mech.value || domain;
                    const mxHosts = await fetchMXRecords(mxDomain);
                    mechTrace.details = `MX: ${mxHosts.join(', ') || 'none'}`;
                    log('info', `SPF 'mx' mechanism: ${mxDomain} MX hosts: ${mxHosts.join(', ') || 'none'}`);
                    for (const mxHost of mxHosts) {
                        lookupCount.count++;
                        if (lookupCount.count > MAX_LOOKUPS) {
                            return { result: 'permerror', reason: 'Too many DNS lookups', lookups: lookupCount.count, trace };
                        }
                        const mxIPs = ipVersion === 4 ? await fetchARecords(mxHost) : await fetchAAAARecords(mxHost);
                        for (const mxIP of mxIPs) {
                            if (ipVersion === 4 && ipv4MatchesCIDR(ip, mxIP + '/32')) {
                                matched = true;
                                break;
                            } else if (ipVersion === 6 && ipv6MatchesCIDR(ip, mxIP + '/128')) {
                                matched = true;
                                break;
                            }
                        }
                        if (matched) break;
                    }
                    break;

                case 'include':
                    lookupCount.count++;
                    if (lookupCount.count > MAX_LOOKUPS) {
                        return { result: 'permerror', reason: 'Too many DNS lookups', lookups: lookupCount.count, trace };
                    }
                    log('info', `SPF 'include' mechanism: checking ${mech.value}`);
                    mechTrace.details = `‚Üí ${mech.value}`;
                    const includeResult = await evaluateSpf(senderIP, mech.value, depth + 1, lookupCount, trace);
                    if (includeResult.result === 'pass') {
                        matched = true;
                        mechTrace.includeResult = 'pass';
                    } else if (includeResult.result === 'permerror' || includeResult.result === 'temperror') {
                        mechTrace.includeResult = includeResult.result;
                        return includeResult;
                    } else {
                        mechTrace.includeResult = includeResult.result;
                    }
                    break;

                case 'redirect':
                    lookupCount.count++;
                    if (lookupCount.count > MAX_LOOKUPS) {
                        return { result: 'permerror', reason: 'Too many DNS lookups', lookups: lookupCount.count, trace };
                    }
                    log('info', `SPF 'redirect' mechanism: redirecting to ${mech.value}`);
                    mechTrace.details = `‚Üí ${mech.value}`;
                    const redirectResult = await evaluateSpf(senderIP, mech.value, depth + 1, lookupCount, trace);
                    redirectResult.trace = trace;
                    return redirectResult;

                case 'exists':
                    lookupCount.count++;
                    if (lookupCount.count > MAX_LOOKUPS) {
                        return { result: 'permerror', reason: 'Too many DNS lookups', lookups: lookupCount.count, trace };
                    }
                    const existsIPs = await fetchARecords(mech.value);
                    matched = existsIPs.length > 0;
                    mechTrace.details = `${mech.value} ${matched ? 'exists' : 'not found'}`;
                    break;

                case 'ptr':
                    // PTR is deprecated and complex, skip for now
                    log('warn', 'PTR mechanism is deprecated and not evaluated');
                    mechTrace.details = 'Deprecated, not evaluated';
                    break;
            }

            mechTrace.matched = matched;

            if (matched) {
                const qualResult = {
                    '+': 'pass',
                    '-': 'fail',
                    '~': 'softfail',
                    '?': 'neutral'
                }[mech.qualifier] || 'neutral';

                domainTrace.matched = mech.raw;
                trace.matchPath.push({ domain, mechanism: mech.raw, result: qualResult });

                log('success', `SPF matched: ${mech.raw} -> ${qualResult}`);
                return {
                    result: qualResult,
                    mechanism: mech.raw,
                    lookups: lookupCount.count,
                    record: spfResult.record,
                    trace
                };
            }
        }

        // No match and no "all" mechanism means neutral
        log('info', 'SPF: No mechanism matched, defaulting to neutral');
        return { result: 'neutral', reason: 'No mechanism matched', lookups: lookupCount.count, record: spfResult.record, trace };
    }

    // Fetch SPF record
    async function fetchSpfRecord(domain) {
        log('info', `SPF lookup: ${domain}`);
        try {
            const res = await fetch(`https://cloudflare-dns.com/dns-query?name=${encodeURIComponent(domain)}&type=TXT`, {
                headers: { Accept: 'application/dns-json' }
            });
            const data = await res.json();
            if (data.Answer) {
                for (const a of data.Answer) {
                    if (a.type === 16) {
                        const record = a.data.replace(/^"|"$/g, '').replace(/" "/g, '');
                        if (record.startsWith('v=spf1')) {
                            log('success', `SPF found: ${record.slice(0, 80)}...`);
                            return { ok: true, record, domain };
                        }
                    }
                }
            }
            log('warn', `No SPF record found for ${domain}`);
            return { ok: false, error: 'No SPF record found', domain };
        } catch (e) {
            log('error', `SPF DNS error: ${e.message}`);
            return { ok: false, error: e.message, domain };
        }
    }

    // Fetch DMARC record
    async function fetchDmarcRecord(domain) {
        const dmarcDomain = `_dmarc.${domain}`;
        log('info', `DMARC lookup: ${dmarcDomain}`);
        try {
            const res = await fetch(`https://cloudflare-dns.com/dns-query?name=${encodeURIComponent(dmarcDomain)}&type=TXT`, {
                headers: { Accept: 'application/dns-json' }
            });
            const data = await res.json();
            if (data.Answer) {
                for (const a of data.Answer) {
                    if (a.type === 16) {
                        const record = a.data.replace(/^"|"$/g, '').replace(/" "/g, '');
                        if (record.startsWith('v=DMARC1')) {
                            log('success', `DMARC found: ${record.slice(0, 80)}...`);
                            return { ok: true, record, domain, dmarcDomain };
                        }
                    }
                }
            }
            log('warn', `No DMARC record found for ${domain}`);
            return { ok: false, error: 'No DMARC record found', domain, dmarcDomain };
        } catch (e) {
            log('error', `DMARC DNS error: ${e.message}`);
            return { ok: false, error: e.message, domain, dmarcDomain };
        }
    }

    // Parse DMARC record into tags
    function parseDmarcRecord(record) {
        const tags = {};
        const re = /([a-z]+)\s*=\s*([^;]+)/gi;
        let m;
        while ((m = re.exec(record))) {
            tags[m[1].toLowerCase()] = m[2].trim();
        }
        return tags;
    }

    // Parse ARC headers from email
    function parseArcHeaders(headers) {
        const arcSets = {};

        // Find all ARC-related headers
        const arcSeals = headers.filter(h => h.name.toLowerCase() === 'arc-seal');
        const arcMsgs = headers.filter(h => h.name.toLowerCase() === 'arc-message-signature');
        const arcAuths = headers.filter(h => h.name.toLowerCase() === 'arc-authentication-results');

        // Parse each ARC-Seal
        for (const seal of arcSeals) {
            const tags = parseArcTags(seal.value);
            const instance = parseInt(tags.i, 10);
            if (!isNaN(instance)) {
                if (!arcSets[instance]) arcSets[instance] = {};
                arcSets[instance].seal = { raw: seal.value, tags };
            }
        }

        // Parse each ARC-Message-Signature
        for (const msg of arcMsgs) {
            const tags = parseArcTags(msg.value);
            const instance = parseInt(tags.i, 10);
            if (!isNaN(instance)) {
                if (!arcSets[instance]) arcSets[instance] = {};
                arcSets[instance].message = { raw: msg.value, tags };
            }
        }

        // Parse each ARC-Authentication-Results
        for (const auth of arcAuths) {
            const parsed = parseArcAuthResults(auth.value);
            const instance = parsed.instance;
            if (instance) {
                if (!arcSets[instance]) arcSets[instance] = {};
                arcSets[instance].auth = { raw: auth.value, parsed };
            }
        }

        // Convert to sorted array
        const sets = Object.entries(arcSets)
            .map(([i, set]) => ({ instance: parseInt(i, 10), ...set }))
            .sort((a, b) => a.instance - b.instance);

        return sets;
    }

    function parseArcTags(value) {
        const unfolded = value.replace(/\r?\n[ \t]+/g, ' ');
        const tags = {};
        const re = /([a-z]+)\s*=\s*([^;]+)/gi;
        let m;
        while ((m = re.exec(unfolded))) {
            let val = m[2].trim();
            if (m[1] === 'b' || m[1] === 'bh') val = val.replace(/\s+/g, '');
            tags[m[1].toLowerCase()] = val;
        }
        return tags;
    }

    function parseArcAuthResults(value) {
        const unfolded = value.replace(/\r?\n[ \t]+/g, ' ');
        const result = { results: [] };

        // Extract instance number (i=N; at the beginning)
        const instanceMatch = unfolded.match(/^\s*i\s*=\s*(\d+)\s*;/);
        if (instanceMatch) {
            result.instance = parseInt(instanceMatch[1], 10);
        }

        // Extract authserv-id (comes after instance)
        const authservMatch = unfolded.match(/;\s*([^;]+?)\s*;/);
        if (authservMatch) {
            result.authserv = authservMatch[1].trim();
        }

        // Extract authentication results
        const dkimMatch = unfolded.match(/dkim\s*=\s*(\w+)/i);
        if (dkimMatch) result.results.push({ method: 'dkim', result: dkimMatch[1].toLowerCase() });

        const spfMatch = unfolded.match(/spf\s*=\s*(\w+)/i);
        if (spfMatch) result.results.push({ method: 'spf', result: spfMatch[1].toLowerCase() });

        const dmarcMatch = unfolded.match(/dmarc\s*=\s*(\w+)/i);
        if (dmarcMatch) result.results.push({ method: 'dmarc', result: dmarcMatch[1].toLowerCase() });

        const arcMatch = unfolded.match(/arc\s*=\s*(\w+)/i);
        if (arcMatch) result.results.push({ method: 'arc', result: arcMatch[1].toLowerCase() });

        return result;
    }

    // Parse SPF record into mechanisms
    function parseSpfRecord(record) {
        const mechanisms = [];
        const parts = record.split(/\s+/).filter(p => p && p !== 'v=spf1');

        for (const part of parts) {
            let qualifier = '+'; // default is pass
            let term = part;

            if (['+', '-', '~', '?'].includes(part[0])) {
                qualifier = part[0];
                term = part.slice(1);
            }

            // Parse mechanism and value
            const colonIdx = term.indexOf(':');
            const eqIdx = term.indexOf('=');
            let mechanism, value;

            if (colonIdx !== -1) {
                mechanism = term.slice(0, colonIdx).toLowerCase();
                value = term.slice(colonIdx + 1);
            } else if (eqIdx !== -1) {
                // For redirect=domain or exp=domain
                mechanism = term.slice(0, eqIdx).toLowerCase();
                value = term.slice(eqIdx + 1);
            } else {
                mechanism = term.toLowerCase();
                value = '';
            }

            mechanisms.push({ qualifier, mechanism, value, raw: part });
        }

        return mechanisms;
    }

    // DNS
    async function fetchDns(domain, selector) {
        const name = `${selector}._domainkey.${domain}`;
        log('info', `DNS lookup: ${name}`);
        try {
            const res = await fetch(`https://cloudflare-dns.com/dns-query?name=${encodeURIComponent(name)}&type=TXT`, {
                headers: { Accept: 'application/dns-json' }
            });
            const data = await res.json();
            if (data.Answer) {
                // Find the DKIM record (starts with v=DKIM1)
                for (const a of data.Answer) {
                    if (a.type === 16) {
                        const record = a.data.replace(/^"|"$/g, '').replace(/" "/g, '');
                        // Only accept records that look like DKIM keys
                        if (record.match(/^v\s*=\s*DKIM1/i) || record.match(/[;]?\s*p\s*=/)) {
                            log('success', `DNS found: ${record.slice(0, 80)}...`);
                            return { ok: true, record, name };
                        }
                    }
                }
                // Fallback: if no DKIM record found, return first TXT record (might be legacy format)
                for (const a of data.Answer) {
                    if (a.type === 16) {
                        const record = a.data.replace(/^"|"$/g, '').replace(/" "/g, '');
                        log('warn', `DNS found non-DKIM TXT: ${record.slice(0, 80)}...`);
                        return { ok: true, record, name };
                    }
                }
            }
            return { ok: false, error: 'No TXT record', name };
        } catch (e) {
            log('error', `DNS error: ${e.message}`);
            return { ok: false, error: e.message, name };
        }
    }

    // Crypto
    function b64ToBuffer(b64) {
        // Clean the base64 string: remove whitespace
        let cleaned = b64.replace(/\s+/g, '');
        // Check for invalid characters before decoding
        const invalidMatch = cleaned.match(/[^A-Za-z0-9+/=]/);
        if (invalidMatch) {
            log('warn', `Base64 contains invalid character: '${invalidMatch[0]}' (charCode ${invalidMatch[0].charCodeAt(0)})`);
            // Remove invalid characters to attempt recovery
            cleaned = cleaned.replace(/[^A-Za-z0-9+/=]/g, '');
        }
        const bin = atob(cleaned);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
        return arr.buffer;
    }

    async function importKey(b64, algorithm = 'rsa-sha256') {
        const keyData = b64ToBuffer(b64);
        const hashAlg = algorithm === 'rsa-sha1' ? 'SHA-1' : 'SHA-256';
        try {
            return await crypto.subtle.importKey('spki', keyData, { name: 'RSASSA-PKCS1-v1_5', hash: hashAlg }, false, ['verify']);
        } catch {
            const spki = convertPkcs1ToSpki(new Uint8Array(keyData));
            return await crypto.subtle.importKey('spki', spki, { name: 'RSASSA-PKCS1-v1_5', hash: hashAlg }, false, ['verify']);
        }
    }

    function convertPkcs1ToSpki(pkcs1) {
        const oid = new Uint8Array([0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00]);
        const bitStr = new Uint8Array(pkcs1.length + 1);
        bitStr[0] = 0x00;
        bitStr.set(pkcs1, 1);
        const bsHeader = asn1Len(0x03, bitStr.length);
        const innerLen = oid.length + bsHeader.length + bitStr.length;
        const seqHeader = asn1Len(0x30, innerLen);
        const spki = new Uint8Array(seqHeader.length + oid.length + bsHeader.length + bitStr.length);
        let o = 0;
        spki.set(seqHeader, o); o += seqHeader.length;
        spki.set(oid, o); o += oid.length;
        spki.set(bsHeader, o); o += bsHeader.length;
        spki.set(bitStr, o);
        return spki.buffer;
    }

    function asn1Len(tag, len) {
        if (len < 128) return new Uint8Array([tag, len]);
        if (len < 256) return new Uint8Array([tag, 0x81, len]);
        return new Uint8Array([tag, 0x82, (len >> 8) & 0xff, len & 0xff]);
    }

    async function computeBodyHash(body, canon, limit, algorithm = 'rsa-sha256') {
        let c = canon === 'relaxed' ? canonBodyRelaxed(body) : canonBodySimple(body);
        if (limit !== undefined && limit !== '') {
            const n = parseInt(limit, 10);
            if (!isNaN(n) && n >= 0) {
                const bytes = new TextEncoder().encode(c);
                if (bytes.length > n) c = new TextDecoder().decode(bytes.slice(0, n));
            }
        }
        const hashAlg = algorithm === 'rsa-sha1' ? 'SHA-1' : 'SHA-256';
        const hash = await crypto.subtle.digest(hashAlg, new TextEncoder().encode(c));
        return btoa(String.fromCharCode(...new Uint8Array(hash)));
    }

    function buildSigningInput(headers, tags, rawDkim, headerCanon) {
        const signed = tags.h.split(':').map(h => h.trim().toLowerCase());
        const headerMap = new Map();
        for (const hdr of headers) {
            const ln = hdr.name.toLowerCase();
            if (!headerMap.has(ln)) headerMap.set(ln, []);
            headerMap.get(ln).push(hdr);
        }
        const lines = [];
        for (const h of signed) {
            const stack = headerMap.get(h);
            if (stack?.length) {
                const hdr = stack.pop();
                if (headerCanon === 'relaxed') {
                    lines.push(canonHeaderRelaxed(hdr.name, hdr.value));
                } else {
                    // Simple canonicalization: use exact raw header
                    lines.push(hdr.raw);
                }
            }
        }
        // Handle DKIM-Signature header for signing (with b= emptied)
        if (headerCanon === 'relaxed') {
            let dkimUnfolded = rawDkim.replace(/\r?\n[ \t]+/g, ' ');
            dkimUnfolded = dkimUnfolded.replace(/(;\s*b\s*=\s*)[A-Za-z0-9+/=\s]+/i, '$1');
            lines.push(canonHeaderRelaxed('DKIM-Signature', dkimUnfolded.replace(/^DKIM-Signature:\s*/i, '')));
        } else {
            // Simple: keep folding, just empty the b= value
            // The b= value can span multiple lines with folding, so match any base64 chars plus whitespace including \r\n
            let dkimSimple = rawDkim.replace(/(;\s*b\s*=\s*)[A-Za-z0-9+/=\r\n\t ]+/i, '$1');
            lines.push(dkimSimple);
        }
        return lines.join('\r\n');
    }

    async function verifySig(input, sig, key) {
        try {
            return await crypto.subtle.verify('RSASSA-PKCS1-v1_5', key, b64ToBuffer(sig), new TextEncoder().encode(input));
        } catch { return false; }
    }

    // Verify signature
    async function verifyDkim(sig, headers, body) {
        const tags = sig.parsed;
        const result = { domain: tags.d || '?', selector: tags.s || '?', tags, raw: sig.raw, status: 'invalid', errors: [], warnings: [], details: {} };

        const required = ['v', 'a', 'b', 'bh', 'd', 'h', 's'];
        for (const t of required) if (!tags[t]) result.errors.push(`Missing tag: ${t}`);
        if (result.errors.length) return result;
        if (tags.v !== '1') { result.errors.push(`Unsupported version: ${tags.v}`); return result; }
        if (tags.a !== 'rsa-sha256' && tags.a !== 'rsa-sha1') { result.errors.push(`Unsupported algorithm: ${tags.a}`); return result; }

        // Security warning for l= tag (body length limit)
        if (tags.l !== undefined && tags.l !== '') {
            const bodyLen = parseInt(tags.l, 10);
            result.warnings.push({
                type: 'body_length_limit',
                message: `Body length limit (l=${bodyLen}) is set`,
                detail: 'Only the first ' + bodyLen + ' bytes of the body are signed. Content after this limit is NOT authenticated and could be malicious.'
            });
            log('warn', `Security: DKIM signature uses l=${bodyLen} tag - body content after ${bodyLen} bytes is unsigned`);
        }

        // Check for signature expiration (x= tag)
        if (tags.x !== undefined && tags.x !== '') {
            const expireTime = parseInt(tags.x, 10);
            const now = Math.floor(Date.now() / 1000);
            result.details.expireTime = expireTime;
            result.details.expireDate = new Date(expireTime * 1000).toISOString();

            if (expireTime < now) {
                const expiredAgo = now - expireTime;
                const expiredDays = Math.floor(expiredAgo / 86400);
                const expiredHours = Math.floor((expiredAgo % 86400) / 3600);
                let expiredStr = '';
                if (expiredDays > 0) expiredStr = `${expiredDays} day${expiredDays > 1 ? 's' : ''}`;
                else if (expiredHours > 0) expiredStr = `${expiredHours} hour${expiredHours > 1 ? 's' : ''}`;
                else expiredStr = `${expiredAgo} second${expiredAgo > 1 ? 's' : ''}`;

                result.warnings.push({
                    type: 'signature_expired',
                    message: `Signature expired ${expiredStr} ago`,
                    detail: `This signature expired on ${new Date(expireTime * 1000).toLocaleString()}. Expired signatures may still technically verify but should be treated with caution.`
                });
                log('warn', `DKIM signature expired: ${new Date(expireTime * 1000).toISOString()}`);
            } else {
                // Signature is valid but show when it expires
                const expiresIn = expireTime - now;
                const expiresDays = Math.floor(expiresIn / 86400);
                if (expiresDays < 7) {
                    result.warnings.push({
                        type: 'signature_expiring_soon',
                        message: `Signature expires in ${expiresDays} day${expiresDays !== 1 ? 's' : ''}`,
                        detail: `This signature will expire on ${new Date(expireTime * 1000).toLocaleString()}.`
                    });
                }
            }
        }

        // Store signature timestamp for display
        if (tags.t !== undefined && tags.t !== '') {
            result.details.signTime = parseInt(tags.t, 10);
            result.details.signDate = new Date(result.details.signTime * 1000).toISOString();
        }

        const [hCanon, bCanon] = (tags.c || 'simple/simple').split('/');
        result.details.headerCanon = hCanon || 'simple';
        result.details.bodyCanon = bCanon || hCanon || 'simple';

        const dns = await fetchDns(tags.d, tags.s);
        result.dns = dns;
        if (!dns.ok) { result.errors.push(`DNS failed: ${dns.error}`); return result; }
        
        result.dnsTags = parseDnsTags(dns.record);
        if (!result.dnsTags.p) { result.errors.push('No public key in DNS'); return result; }

        const computedBh = await computeBodyHash(body, result.details.bodyCanon, tags.l, tags.a);
        result.details.computedBh = computedBh;
        result.details.declaredBh = tags.bh;
        result.details.bhMatch = computedBh === tags.bh;
        if (!result.details.bhMatch) result.errors.push('Body hash mismatch');

        try {
            const key = await importKey(result.dnsTags.p, tags.a);
            const input = buildSigningInput(headers, tags, sig.raw, result.details.headerCanon);
            result.details.sigValid = await verifySig(input, tags.b, key);
            if (!result.details.sigValid) result.errors.push('Signature verification failed');
        } catch (e) {
            result.errors.push(`Crypto error: ${e.message}`);
            result.details.sigValid = false;
        }

        result.status = result.details.bhMatch && result.details.sigValid ? 'valid' : 'invalid';
        log(result.status === 'valid' ? 'success' : 'error', `${tags.d}: ${result.status.toUpperCase()}`);
        return result;
    }

    // Render
    function renderTag(name, value, info, classes = '') {
        const short = value.length > 25 ? value.slice(0, 25) + '‚Ä¶' : value;
        return `<div class="tag ${classes}" data-tag="${esc(name)}" data-tag-name="${esc(info.name)}" data-tag-desc="${esc(info.desc)}" data-tag-value="${esc(value)}">
            <span class="dot"></span>
            <span class="tag-name">${esc(name)}</span>
            <span class="tag-value">${esc(short)}</span>
            <button class="copy-btn" onclick="event.stopPropagation();copy(this,\`${esc(value.replace(/`/g, ''))}\`)">‚ßâ</button>
        </div>`;
    }

    function renderHeaders(headers, signed) {
        const tags = headers.map(hdr => {
            const isSigned = signed.has(hdr.name.toLowerCase());
            // Unfold value for display
            const displayValue = hdr.value.replace(/\r?\n[ \t]+/g, ' ').trim();
            return renderTag(hdr.name, displayValue, { name: hdr.name, desc: isSigned ? 'Included in DKIM signature' : 'Not signed' }, `header ${isSigned ? 'signed' : ''}`);
        }).join('');
        return `<div class="headers-section">
            <div class="section-header">üì® Email Headers</div>
            <div class="tags-grid">${tags}</div>
            <div class="legend">
                <div class="legend-item"><span class="dot" style="background:linear-gradient(135deg,var(--success),var(--accent));width:6px;height:6px;border-radius:50%"></span> Signed</div>
                <div class="legend-item"><span class="dot" style="background:var(--text-dim);width:6px;height:6px;border-radius:50%"></span> Not signed</div>
            </div>
        </div>`;
    }

    function renderSig(r, i) {
        const errHtml = r.errors.map(e => `<div class="error-msg">${esc(e)}</div>`).join('');
        const warnHtml = (r.warnings || []).map(w => `<div class="warning-msg">‚ö†Ô∏è <strong>Security Warning:</strong> ${esc(w.message)}<span class="suggestion">${esc(w.detail)}</span></div>`).join('');
        const dkimTags = Object.entries(r.tags).map(([k, v]) => renderTag(k, v, DKIM_TAGS[k] || { name: k.toUpperCase(), desc: 'DKIM tag' }, 'signed')).join('');
        const dnsTags = r.dnsTags ? Object.entries(r.dnsTags).map(([k, v]) => renderTag(k, v, DNS_TAGS[k] || { name: k.toUpperCase(), desc: 'DNS tag' }, 'dns')).join('') : '';
        const dnsCmd = `dig TXT ${r.dns?.name || r.selector + '._domainkey.' + r.domain}`;
        const hasWarnings = r.warnings && r.warnings.length > 0;

        return `<div class="sig-card ${r.status} expanded">
            <div class="sig-header" onclick="toggleCard(this)">
                <div class="sig-title">
                    <span class="sig-num">${i}</span>
                    <span class="sig-domain">${esc(r.domain)}</span>
                    <span class="badge ${r.status}">${r.status === 'valid' ? '‚úì PASS' : '‚úó FAIL'}</span>
                    ${hasWarnings ? '<span class="badge" style="background:rgba(255,179,71,0.15);color:var(--warning);margin-left:0.5rem">‚ö†Ô∏è WARNING</span>' : ''}
                </div>
                <span class="expand-icon">‚ñº</span>
            </div>
            <div class="sig-content"><div class="sig-body">
                ${errHtml}
                ${warnHtml}
                <div class="sig-section">
                    <div class="sig-section-title">üè∑Ô∏è DKIM Tags</div>
                    <div class="tags-grid">${dkimTags}</div>
                </div>
                <div class="sig-section">
                    <div class="sig-section-title">üåê DNS Record</div>
                    <div class="dns-cmd">
                        <code>${esc(dnsCmd)}</code>
                        <button class="copy-btn" style="opacity:1" onclick="event.stopPropagation();copy(this,'${esc(dnsCmd)}')">‚ßâ</button>
                    </div>
                    ${r.dns?.ok ? `<div class="tags-grid">${dnsTags}</div><div class="dns-raw">${esc(r.dns.record)}</div>` : `<div class="error-msg">${esc(r.dns?.error || 'DNS lookup failed')}</div>`}
                </div>
                <div class="sig-section">
                    <div class="sig-section-title">üîê Verification</div>
                    <div class="details">
                        <div class="detail-row"><span class="detail-label">Algorithm</span><span class="detail-value">${esc(r.tags.a || 'N/A')}</span></div>
                        <div class="detail-row"><span class="detail-label">Canonicalization</span><span class="detail-value">${r.details.headerCanon}/${r.details.bodyCanon}</span></div>
                        <div class="detail-row"><span class="detail-label">Body Hash</span><span class="detail-value ${r.details.bhMatch ? 'success' : 'error'}">${r.details.bhMatch ? '‚úì Match' : '‚úó Mismatch'}</span></div>
                        <div class="detail-row"><span class="detail-label">Signature</span><span class="detail-value ${r.details.sigValid ? 'success' : 'error'}">${r.details.sigValid ? '‚úì Valid' : '‚úó Invalid'}</span></div>
                        ${r.details.signDate ? `<div class="detail-row"><span class="detail-label">Signed</span><span class="detail-value">${new Date(r.details.signTime * 1000).toLocaleString()}</span></div>` : ''}
                        ${r.details.expireDate ? `<div class="detail-row"><span class="detail-label">Expires</span><span class="detail-value ${r.details.expireTime < Math.floor(Date.now() / 1000) ? 'error' : ''}">${new Date(r.details.expireTime * 1000).toLocaleString()}${r.details.expireTime < Math.floor(Date.now() / 1000) ? ' (EXPIRED)' : ''}</span></div>` : ''}
                    </div>
                </div>
            </div></div>
        </div>`;
    }

    function renderDebug() {
        return logs.map(l => `<div class="log-entry"><span class="log-time">${l.time}</span><span class="log-type ${l.type}">${l.type.toUpperCase()}</span><span class="log-msg">${esc(l.msg)}</span></div>`).join('');
    }

    function renderSpfMechanism(mech) {
        const qualInfo = SPF_QUALIFIERS[mech.qualifier] || { name: 'Unknown', desc: 'Unknown qualifier', color: 'neutral' };
        const mechInfo = SPF_MECHANISMS[mech.mechanism] || { name: mech.mechanism.toUpperCase(), desc: 'SPF mechanism' };
        const displayValue = mech.value || (mech.mechanism === 'all' ? '' : '(domain)');
        const tagClass = `spf-${qualInfo.color === 'success' ? 'pass' : qualInfo.color === 'error' ? 'fail' : qualInfo.color === 'warning' ? 'softfail' : 'neutral'}`;

        return `<div class="tag ${tagClass}" data-tag="${esc(mech.raw)}" data-tag-name="${esc(qualInfo.name + ' ' + mechInfo.name)}" data-tag-desc="${esc(mechInfo.desc + '. Qualifier: ' + qualInfo.desc)}" data-tag-value="${esc(mech.raw)}">
            <span class="dot"></span>
            <span class="tag-name">${esc(mech.qualifier)}${esc(mech.mechanism)}</span>
            ${displayValue ? `<span class="tag-value">${esc(displayValue)}</span>` : ''}
            <button class="copy-btn" onclick="event.stopPropagation();copy(this,\`${esc(mech.raw)}\`)">‚ßâ</button>
        </div>`;
    }

    function renderSpf(spfResult) {
        if (!spfResult) return '';

        const dnsCmd = `dig TXT ${spfResult.domain}`;
        const statusClass = spfResult.ok ? 'found' : 'notfound';
        const statusBadge = spfResult.ok ? '<span class="badge" style="background:rgba(0,212,255,0.15);color:var(--accent-secondary)">FOUND</span>' : '<span class="badge" style="background:rgba(255,179,71,0.15);color:var(--warning)">NOT FOUND</span>';

        let content = '';
        if (spfResult.ok) {
            const mechanisms = parseSpfRecord(spfResult.record);
            const mechTags = mechanisms.map(m => renderSpfMechanism(m)).join('');

            content = `
                <div class="sig-section">
                    <div class="sig-section-title">üõ°Ô∏è SPF Mechanisms</div>
                    <div class="tags-grid">${mechTags}</div>
                </div>
                <div class="sig-section">
                    <div class="sig-section-title">üåê DNS Record</div>
                    <div class="dns-cmd">
                        <code>${esc(dnsCmd)}</code>
                        <button class="copy-btn" style="opacity:1" onclick="event.stopPropagation();copy(this,'${esc(dnsCmd)}')">‚ßâ</button>
                    </div>
                    <div class="dns-raw">${esc(spfResult.record)}</div>
                </div>
                <div class="sig-section">
                    <div class="sig-section-title">üìã Policy Summary</div>
                    <div class="details">
                        <div class="detail-row"><span class="detail-label">Domain</span><span class="detail-value">${esc(spfResult.domain)}</span></div>
                        <div class="detail-row"><span class="detail-label">Mechanisms</span><span class="detail-value">${mechanisms.length}</span></div>
                        <div class="detail-row"><span class="detail-label">Default Policy</span><span class="detail-value ${getDefaultPolicyClass(mechanisms)}">${getDefaultPolicy(mechanisms)}</span></div>
                    </div>
                </div>
            `;
        } else {
            content = `<div class="error-msg">${esc(spfResult.error)} for ${esc(spfResult.domain)}</div>`;
        }

        return `<div class="spf-card ${statusClass} expanded">
            <div class="sig-header" onclick="toggleCard(this)">
                <div class="sig-title">
                    <span class="sig-num">üõ°Ô∏è</span>
                    <span class="sig-domain">${esc(spfResult.domain)}</span>
                    ${statusBadge}
                </div>
                <span class="expand-icon">‚ñº</span>
            </div>
            <div class="sig-content"><div class="sig-body">
                ${content}
            </div></div>
        </div>`;
    }

    function getDefaultPolicy(mechanisms) {
        const allMech = mechanisms.find(m => m.mechanism === 'all');
        if (!allMech) return 'None (default: neutral)';
        const qual = SPF_QUALIFIERS[allMech.qualifier];
        return qual ? qual.name : 'Unknown';
    }

    function getDefaultPolicyClass(mechanisms) {
        const allMech = mechanisms.find(m => m.mechanism === 'all');
        if (!allMech) return 'neutral';
        const qual = SPF_QUALIFIERS[allMech.qualifier];
        return qual ? qual.color : 'neutral';
    }

    function renderSpfEvaluation(evalResult) {
        if (!evalResult) return '';

        const resultInfo = SPF_RESULTS[evalResult.result] || SPF_RESULTS.none;
        const dnsCmd = `dig TXT ${evalResult.domain}`;

        // Determine badge styling based on result
        let badgeStyle, badgeText;
        switch (evalResult.result) {
            case 'pass':
                badgeStyle = 'background:rgba(0,255,136,0.15);color:var(--success)';
                badgeText = '‚úì PASS';
                break;
            case 'fail':
                badgeStyle = 'background:rgba(255,107,122,0.15);color:var(--error)';
                badgeText = '‚úó FAIL';
                break;
            case 'softfail':
                badgeStyle = 'background:rgba(255,179,71,0.15);color:var(--warning)';
                badgeText = '~ SOFTFAIL';
                break;
            case 'neutral':
                badgeStyle = 'background:rgba(139,148,158,0.15);color:var(--text-secondary)';
                badgeText = '? NEUTRAL';
                break;
            case 'none':
                badgeStyle = 'background:rgba(139,148,158,0.15);color:var(--text-secondary)';
                badgeText = '‚àí NONE';
                break;
            case 'permerror':
            case 'temperror':
                badgeStyle = 'background:rgba(255,107,122,0.15);color:var(--error)';
                badgeText = '! ERROR';
                break;
            default:
                badgeStyle = 'background:rgba(139,148,158,0.15);color:var(--text-secondary)';
                badgeText = evalResult.result.toUpperCase();
        }

        let content = '';

        // Evaluation result section
        content += `
            <div class="sig-section">
                <div class="sig-section-title">üìä SPF Evaluation Result</div>
                <div class="details">
                    <div class="detail-row"><span class="detail-label">Result</span><span class="detail-value ${resultInfo.color}">${resultInfo.icon} ${resultInfo.name}</span></div>
                    <div class="detail-row"><span class="detail-label">Description</span><span class="detail-value">${esc(resultInfo.desc)}</span></div>
                    ${evalResult.senderIP ? `<div class="detail-row"><span class="detail-label">Sender IP</span><span class="detail-value">${esc(evalResult.senderIP.ip)} (IPv${evalResult.senderIP.version})</span></div>` : ''}
                    ${evalResult.mechanism ? `<div class="detail-row"><span class="detail-label">Matched Mechanism</span><span class="detail-value" style="color:var(--accent)">${esc(evalResult.mechanism)}</span></div>` : ''}
                    ${evalResult.reason ? `<div class="detail-row"><span class="detail-label">Reason</span><span class="detail-value">${esc(evalResult.reason)}</span></div>` : ''}
                    ${evalResult.lookups !== undefined ? `<div class="detail-row"><span class="detail-label">DNS Lookups</span><span class="detail-value">${evalResult.lookups}/10</span></div>` : ''}
                </div>
            </div>
        `;

        // SPF mechanisms if record exists
        if (evalResult.record) {
            const mechanisms = parseSpfRecord(evalResult.record);
            const mechTags = mechanisms.map(m => renderSpfMechanism(m)).join('');

            content += `
                <div class="sig-section">
                    <div class="sig-section-title">üõ°Ô∏è SPF Mechanisms</div>
                    <div class="tags-grid">${mechTags}</div>
                </div>
                <div class="sig-section">
                    <div class="sig-section-title">üåê DNS Record</div>
                    <div class="dns-cmd">
                        <code>${esc(dnsCmd)}</code>
                        <button class="copy-btn" style="opacity:1" onclick="event.stopPropagation();copy(this,'${esc(dnsCmd)}')">‚ßâ</button>
                    </div>
                    <div class="dns-raw">${esc(evalResult.record)}</div>
                </div>
                <div class="sig-section">
                    <div class="sig-section-title">üìã Policy Summary</div>
                    <div class="details">
                        <div class="detail-row"><span class="detail-label">Domain</span><span class="detail-value">${esc(evalResult.domain)}</span></div>
                        <div class="detail-row"><span class="detail-label">Mechanisms</span><span class="detail-value">${mechanisms.length}</span></div>
                        <div class="detail-row"><span class="detail-label">Default Policy</span><span class="detail-value ${getDefaultPolicyClass(mechanisms)}">${getDefaultPolicy(mechanisms)}</span></div>
                    </div>
                </div>
            `;
        }

        // Render recursive trace if available
        if (evalResult.trace && evalResult.trace.domains && evalResult.trace.domains.length > 0) {
            content += `
                <div class="spf-trace">
                    <div class="spf-trace-title">üîç Recursive SPF Trace (${evalResult.trace.domains.length} domain${evalResult.trace.domains.length > 1 ? 's' : ''} evaluated)</div>
            `;

            // Render each domain trace
            for (const domainTrace of evalResult.trace.domains) {
                const depthClass = `depth-${Math.min(domainTrace.depth, 3)}`;
                content += `
                    <div class="spf-domain-trace ${depthClass}">
                        <div class="spf-domain-header">
                            <span class="spf-domain-name">${esc(domainTrace.domain)}</span>
                            <span class="spf-domain-depth">Depth ${domainTrace.depth}</span>
                        </div>
                `;

                if (domainTrace.record) {
                    const truncRecord = domainTrace.record.length > 100
                        ? domainTrace.record.substring(0, 100) + '...'
                        : domainTrace.record;
                    content += `<div class="spf-record-preview">${esc(truncRecord)}</div>`;
                }

                if (domainTrace.mechanisms && domainTrace.mechanisms.length > 0) {
                    content += `<div class="spf-mechanisms-list">`;
                    for (const mech of domainTrace.mechanisms) {
                        const matchClass = mech.matched ? 'matched' : 'not-matched';
                        const detailsStr = mech.details ? ` ‚Üí ${mech.details}` : '';
                        content += `
                            <div class="spf-mech ${matchClass}">
                                <span class="spf-mech-indicator"></span>
                                <span class="spf-mech-text">${esc(mech.mechanism)}</span>
                                ${detailsStr ? `<span class="spf-mech-details">${esc(detailsStr)}</span>` : ''}
                            </div>
                        `;
                    }
                    content += `</div>`;
                }

                content += `</div>`;
            }

            // Render match path if there was a match
            if (evalResult.trace.matchPath && evalResult.trace.matchPath.length > 0) {
                content += `
                    <div class="spf-match-path">
                        <div class="spf-match-path-title">‚úì Match Path</div>
                        <div class="spf-match-path-chain">
                `;
                evalResult.trace.matchPath.forEach((item, idx) => {
                    if (idx > 0) {
                        content += `<span class="spf-match-path-arrow">‚Üí</span>`;
                    }
                    content += `<span class="spf-match-path-item">${esc(item.domain)}: ${esc(item.mechanism)}</span>`;
                });
                content += `
                        </div>
                    </div>
                `;
            }

            content += `</div>`;
        }

        const cardClass = evalResult.result === 'pass' ? 'found' : (evalResult.result === 'fail' || evalResult.result === 'permerror' ? 'notfound' : '');

        return `<div class="spf-card ${cardClass} expanded">
            <div class="sig-header" onclick="toggleCard(this)">
                <div class="sig-title">
                    <span class="sig-num">üõ°Ô∏è</span>
                    <span class="sig-domain">${esc(evalResult.domain)}</span>
                    <span class="badge" style="${badgeStyle}">${badgeText}</span>
                </div>
                <span class="expand-icon">‚ñº</span>
            </div>
            <div class="sig-content"><div class="sig-body">
                ${content}
            </div></div>
        </div>`;
    }

    // Render DMARC tag
    function renderDmarcTag(name, value) {
        const info = DMARC_TAGS[name] || { name: name.toUpperCase(), desc: 'DMARC tag' };
        let tagClass = '';
        if (name === 'p' || name === 'sp') {
            tagClass = `dmarc-${value.toLowerCase()}`;
        }
        const short = value.length > 30 ? value.slice(0, 30) + '‚Ä¶' : value;
        return `<div class="tag ${tagClass}" data-tag="${esc(name)}" data-tag-name="${esc(info.name)}" data-tag-desc="${esc(info.desc)}" data-tag-value="${esc(value)}">
            <span class="dot"></span>
            <span class="tag-name">${esc(name)}</span>
            <span class="tag-value">${esc(short)}</span>
            <button class="copy-btn" onclick="event.stopPropagation();copy(this,\`${esc(value.replace(/`/g, ''))}\`)">‚ßâ</button>
        </div>`;
    }

    // Render DMARC result
    function renderDmarc(dmarcResult) {
        if (!dmarcResult) return '';

        const dnsCmd = `dig TXT _dmarc.${dmarcResult.domain}`;

        if (!dmarcResult.ok) {
            return `<div class="dmarc-card notfound expanded">
                <div class="sig-header" onclick="toggleCard(this)">
                    <div class="sig-title">
                        <span class="sig-num">üìã</span>
                        <span class="sig-domain">DMARC Policy</span>
                        <span class="badge" style="background:rgba(255,107,122,0.15);color:var(--error)">NOT FOUND</span>
                    </div>
                    <span class="expand-icon">‚ñº</span>
                </div>
                <div class="sig-content"><div class="sig-body">
                    <div class="error-msg">${esc(dmarcResult.error)} for ${esc(dmarcResult.domain)}</div>
                    <div class="sig-section">
                        <div class="sig-section-title">üåê DNS Lookup</div>
                        <div class="dns-cmd">
                            <code>${esc(dnsCmd)}</code>
                            <button class="copy-btn" style="opacity:1" onclick="event.stopPropagation();copy(this,'${esc(dnsCmd)}')">‚ßâ</button>
                        </div>
                    </div>
                </div></div>
            </div>`;
        }

        const tags = parseDmarcRecord(dmarcResult.record);
        const policy = tags.p?.toLowerCase() || 'none';
        const policyInfo = DMARC_POLICIES[policy] || DMARC_POLICIES.none;

        // Determine badge styling
        let badgeStyle, badgeText;
        switch (policy) {
            case 'reject':
                badgeStyle = 'background:rgba(0,255,136,0.15);color:var(--success)';
                badgeText = '‚úì REJECT';
                break;
            case 'quarantine':
                badgeStyle = 'background:rgba(255,179,71,0.15);color:var(--warning)';
                badgeText = '‚ö† QUARANTINE';
                break;
            default:
                badgeStyle = 'background:rgba(139,148,158,0.15);color:var(--text-secondary)';
                badgeText = '? NONE';
        }

        const dmarcTags = Object.entries(tags).map(([k, v]) => renderDmarcTag(k, v)).join('');

        return `<div class="dmarc-card ${policy} expanded">
            <div class="sig-header" onclick="toggleCard(this)">
                <div class="sig-title">
                    <span class="sig-num">üìã</span>
                    <span class="sig-domain">DMARC Policy</span>
                    <span class="badge" style="${badgeStyle}">${badgeText}</span>
                </div>
                <span class="expand-icon">‚ñº</span>
            </div>
            <div class="sig-content"><div class="sig-body">
                <div class="sig-section">
                    <div class="sig-section-title">üìä Policy Details</div>
                    <div class="details">
                        <div class="detail-row"><span class="detail-label">Policy</span><span class="detail-value ${policyInfo.color}">${policyInfo.icon} ${policyInfo.name}</span></div>
                        <div class="detail-row"><span class="detail-label">Description</span><span class="detail-value">${esc(policyInfo.desc)}</span></div>
                        ${tags.sp ? `<div class="detail-row"><span class="detail-label">Subdomain Policy</span><span class="detail-value">${esc(tags.sp)}</span></div>` : ''}
                        <div class="detail-row"><span class="detail-label">DKIM Alignment</span><span class="detail-value">${tags.adkim === 's' ? 'Strict' : 'Relaxed'}</span></div>
                        <div class="detail-row"><span class="detail-label">SPF Alignment</span><span class="detail-value">${tags.aspf === 's' ? 'Strict' : 'Relaxed'}</span></div>
                        ${tags.pct ? `<div class="detail-row"><span class="detail-label">Percentage Applied</span><span class="detail-value">${esc(tags.pct)}%</span></div>` : ''}
                    </div>
                </div>
                <div class="sig-section">
                    <div class="sig-section-title">üè∑Ô∏è DMARC Tags</div>
                    <div class="tags-grid">${dmarcTags}</div>
                </div>
                ${tags.rua || tags.ruf ? `<div class="sig-section">
                    <div class="sig-section-title">üì¨ Reporting</div>
                    <div class="details">
                        ${tags.rua ? `<div class="detail-row"><span class="detail-label">Aggregate Reports</span><span class="detail-value" style="word-break:break-all">${esc(tags.rua)}</span></div>` : ''}
                        ${tags.ruf ? `<div class="detail-row"><span class="detail-label">Forensic Reports</span><span class="detail-value" style="word-break:break-all">${esc(tags.ruf)}</span></div>` : ''}
                        ${tags.ri ? `<div class="detail-row"><span class="detail-label">Report Interval</span><span class="detail-value">${esc(tags.ri)} seconds</span></div>` : ''}
                    </div>
                </div>` : ''}
                <div class="sig-section">
                    <div class="sig-section-title">üåê DNS Record</div>
                    <div class="dns-cmd">
                        <code>${esc(dnsCmd)}</code>
                        <button class="copy-btn" style="opacity:1" onclick="event.stopPropagation();copy(this,'${esc(dnsCmd)}')">‚ßâ</button>
                    </div>
                    <div class="dns-raw">${esc(dmarcResult.record)}</div>
                </div>
            </div></div>
        </div>`;
    }

    // Render ARC chain
    function renderArc(arcSets) {
        if (!arcSets || arcSets.length === 0) {
            return ''; // Don't show ARC section if no ARC headers
        }

        // Determine overall chain status from the latest seal
        const latestSet = arcSets[arcSets.length - 1];
        const chainStatus = latestSet?.seal?.tags?.cv?.toLowerCase() || 'none';
        const statusInfo = ARC_CV_STATUS[chainStatus] || ARC_CV_STATUS.none;

        // Badge styling
        let badgeStyle, badgeText;
        switch (chainStatus) {
            case 'pass':
                badgeStyle = 'background:rgba(0,255,136,0.15);color:var(--success)';
                badgeText = '‚úì PASS';
                break;
            case 'fail':
                badgeStyle = 'background:rgba(255,107,122,0.15);color:var(--error)';
                badgeText = '‚úó FAIL';
                break;
            default:
                badgeStyle = 'background:rgba(139,148,158,0.15);color:var(--text-secondary)';
                badgeText = '‚àí NONE';
        }

        // Render each ARC set
        const setsHtml = arcSets.map(set => {
            const sealTags = set.seal?.tags || {};
            const msgTags = set.message?.tags || {};
            const authResults = set.auth?.parsed?.results || [];
            const domain = sealTags.d || msgTags.d || 'unknown';

            // Render auth results
            const authHtml = authResults.map(r => {
                const resultClass = r.result === 'pass' ? 'success' : (r.result === 'fail' ? 'error' : 'warning');
                return `<span class="relay-hop-detail">${r.method}: <span style="color:var(--${resultClass})">${r.result}</span></span>`;
            }).join('');

            // Render seal tags
            const sealTagsHtml = Object.entries(sealTags)
                .filter(([k]) => k !== 'b') // Don't show full signature
                .map(([k, v]) => {
                    const info = ARC_SEAL_TAGS[k] || { name: k.toUpperCase(), desc: 'ARC tag' };
                    const short = v.length > 20 ? v.slice(0, 20) + '‚Ä¶' : v;
                    return `<div class="tag" data-tag="${esc(k)}" data-tag-name="${esc(info.name)}" data-tag-desc="${esc(info.desc)}" data-tag-value="${esc(v)}">
                        <span class="dot"></span>
                        <span class="tag-name">${esc(k)}</span>
                        <span class="tag-value">${esc(short)}</span>
                    </div>`;
                }).join('');

            const cvStatus = sealTags.cv?.toLowerCase() || 'none';
            const cvInfo = ARC_CV_STATUS[cvStatus] || ARC_CV_STATUS.none;

            return `
                <div class="arc-set">
                    <div class="arc-set-header">
                        <span class="arc-set-title">ARC Set #${set.instance}</span>
                        <span class="arc-set-domain">${esc(domain)}</span>
                    </div>
                    <div class="arc-component">
                        <div class="arc-component-label">Chain Validation (cv=)</div>
                        <span class="detail-value ${cvInfo.color}">${cvInfo.icon} ${cvInfo.name}</span>
                    </div>
                    ${authResults.length > 0 ? `<div class="arc-component">
                        <div class="arc-component-label">Authentication Results</div>
                        <div class="relay-hop-details">${authHtml}</div>
                    </div>` : ''}
                    <div class="arc-component">
                        <div class="arc-component-label">ARC-Seal Tags</div>
                        <div class="tags-grid">${sealTagsHtml}</div>
                    </div>
                </div>
            `;
        }).join('');

        return `<div class="arc-card ${chainStatus} expanded">
            <div class="sig-header" onclick="toggleCard(this)">
                <div class="sig-title">
                    <span class="sig-num">üîó</span>
                    <span class="sig-domain">ARC Chain</span>
                    <span class="badge" style="${badgeStyle}">${badgeText}</span>
                    <span class="badge" style="background:var(--glass);color:var(--text-secondary);margin-left:0.5rem">${arcSets.length} SET${arcSets.length > 1 ? 'S' : ''}</span>
                </div>
                <span class="expand-icon">‚ñº</span>
            </div>
            <div class="sig-content"><div class="sig-body">
                <div class="sig-section">
                    <div class="sig-section-title">üìä Chain Status</div>
                    <div class="details">
                        <div class="detail-row"><span class="detail-label">Chain Validation</span><span class="detail-value ${statusInfo.color}">${statusInfo.icon} ${statusInfo.name}</span></div>
                        <div class="detail-row"><span class="detail-label">Description</span><span class="detail-value">${esc(statusInfo.desc)}</span></div>
                        <div class="detail-row"><span class="detail-label">Total Sets</span><span class="detail-value">${arcSets.length}</span></div>
                    </div>
                </div>
                <div class="sig-section">
                    <div class="sig-section-title">üîó ARC Sets (oldest first)</div>
                    ${setsHtml}
                </div>
            </div></div>
        </div>`;
    }

    // Initialize tooltips on all tags in the results
    function initTooltips() {
        document.querySelectorAll('#results .tag').forEach(tag => {
            Tooltip.attachToTag(tag);
        });
    }

    // Main validate
    async function validate() {
        logs.length = 0;
        const input = document.getElementById('input').value.trim();
        if (!input) return;

        log('info', 'Starting validation');
        const { headers, body, dkimSigs, errors, warnings } = parseEmail(input);

        // Display parsing issues if any
        let parsingIssuesHtml = '';
        if (errors && errors.length > 0) {
            const errorsHtml = errors.map(e => `<div class="error-msg">${esc(e.message)}${e.suggestion ? `<span class="suggestion">üí° ${esc(e.suggestion)}</span>` : ''}</div>`).join('');
            parsingIssuesHtml += errorsHtml;
            errors.forEach(e => log('error', e.message));
        }
        if (warnings && warnings.length > 0) {
            const warningsHtml = warnings.map(w => `<div class="warning-msg">${esc(w.message)}${w.suggestion ? `<span class="suggestion">üí° ${esc(w.suggestion)}</span>` : ''}</div>`).join('');
            parsingIssuesHtml += warningsHtml;
            warnings.forEach(w => log('warn', w.message));
        }

        if (parsingIssuesHtml) {
            const issueClass = errors?.length > 0 ? 'has-errors' : 'has-warnings';
            document.getElementById('parsingIssuesEl').innerHTML = `<div class="parsing-issues ${issueClass}">
                <div class="section-header">‚ö†Ô∏è Parsing Issues</div>
                ${parsingIssuesHtml}
            </div>`;
        } else {
            document.getElementById('parsingIssuesEl').innerHTML = '';
        }

        // If critical errors, still show what we can but continue
        if (errors && errors.length > 0 && headers.length === 0) {
            document.getElementById('headersEl').innerHTML = '';
            document.getElementById('summaryEl').innerHTML = '';
            document.getElementById('relayEl').innerHTML = '';
            document.getElementById('spfEl').innerHTML = '';
            document.getElementById('dmarcEl').innerHTML = '';
            document.getElementById('arcEl').innerHTML = '';
            document.getElementById('sigsEl').innerHTML = '';
            document.getElementById('debugLog').innerHTML = renderDebug();
            document.getElementById('results').classList.add('visible');
            document.getElementById('status').innerHTML = '';
            return;
        }

        const signed = new Set();
        dkimSigs.forEach(s => s.parsed?.h?.split(':').forEach(h => signed.add(h.trim().toLowerCase())));

        document.getElementById('headersEl').innerHTML = renderHeaders(headers, signed);

        // Parse and render email relay chain
        const relayHops = parseRelayChain(headers);
        document.getElementById('relayEl').innerHTML = renderRelayChain(relayHops);
        log('info', `Found ${relayHops.length} relay hops`);

        // SPF check with full evaluation
        const mailDomain = extractMailDomain(headers);
        const senderIP = extractSenderIP(headers);
        let spfEvalResult = null;
        if (mailDomain && senderIP) {
            spfEvalResult = await evaluateSpf(senderIP, mailDomain);
            spfEvalResult.senderIP = senderIP;
            spfEvalResult.domain = mailDomain;
        } else if (mailDomain) {
            // Fallback: just fetch SPF record without evaluation
            const spfRecord = await fetchSpfRecord(mailDomain);
            spfEvalResult = {
                result: 'none',
                reason: 'Could not extract sender IP from headers',
                record: spfRecord.ok ? spfRecord.record : null,
                domain: mailDomain,
                senderIP: null
            };
            log('warn', 'Could not extract sender IP for SPF evaluation');
        } else {
            log('warn', 'Could not extract mail domain for SPF check');
        }
        document.getElementById('spfEl').innerHTML = spfEvalResult ? renderSpfEvaluation(spfEvalResult) : '<div class="error-msg">Could not determine sender domain for SPF lookup</div>';

        // DMARC check
        let dmarcResult = null;
        if (mailDomain) {
            dmarcResult = await fetchDmarcRecord(mailDomain);
        }
        document.getElementById('dmarcEl').innerHTML = dmarcResult ? renderDmarc(dmarcResult) : '';

        // ARC chain parsing and display
        const arcSets = parseArcHeaders(headers);
        document.getElementById('arcEl').innerHTML = renderArc(arcSets);
        if (arcSets.length > 0) {
            log('info', `Found ${arcSets.length} ARC set(s) in chain`);
        }

        // Determine SPF summary display
        const spfSummaryClass = spfEvalResult?.result === 'pass' ? 'success' : (spfEvalResult?.result === 'fail' || spfEvalResult?.result === 'permerror' ? 'error' : 'warning');
        const spfSummaryIcon = spfEvalResult?.result === 'pass' ? '‚úì' : (spfEvalResult?.result === 'fail' || spfEvalResult?.result === 'permerror' ? '‚úó' : '?');
        const spfSummaryLabel = spfEvalResult ? (SPF_RESULTS[spfEvalResult.result]?.name || 'Unknown') : 'N/A';

        if (!dkimSigs.length) {
            document.getElementById('summaryEl').innerHTML = `
                <div class="summary-item"><div class="summary-icon">üõ°Ô∏è</div><div><span class="summary-value ${spfSummaryClass}">${spfSummaryIcon}</span><div class="summary-label">SPF ${spfSummaryLabel}</div></div></div>
                <div class="summary-item"><div class="summary-icon">üìß</div><div><span class="summary-value">0</span><div class="summary-label">DKIM Signatures</div></div></div>
            `;
            document.getElementById('sigsEl').innerHTML = '<div class="error-msg">No DKIM-Signature headers found</div>';
            document.getElementById('debugLog').innerHTML = renderDebug();
            document.getElementById('results').classList.add('visible');
            document.getElementById('status').innerHTML = '';
            initTooltips();
            return;
        }

        const results = [];
        for (const sig of dkimSigs) {
            results.push(await verifyDkim(sig, headers, body));
        }

        const valid = results.filter(r => r.status === 'valid').length;
        const invalid = results.length - valid;

        document.getElementById('summaryEl').innerHTML = `
            <div class="summary-item"><div class="summary-icon">üõ°Ô∏è</div><div><span class="summary-value ${spfSummaryClass}">${spfSummaryIcon}</span><div class="summary-label">SPF ${spfSummaryLabel}</div></div></div>
            <div class="summary-item"><div class="summary-icon">üìß</div><div><span class="summary-value">${results.length}</span><div class="summary-label">DKIM Signatures</div></div></div>
            <div class="summary-item"><div class="summary-icon">‚úì</div><div><span class="summary-value success">${valid}</span><div class="summary-label">Valid</div></div></div>
            <div class="summary-item"><div class="summary-icon">‚úó</div><div><span class="summary-value error">${invalid}</span><div class="summary-label">Invalid</div></div></div>
        `;

        document.getElementById('sigsEl').innerHTML = results.map((r, i) => renderSig(r, i + 1)).join('');
        document.getElementById('debugLog').innerHTML = renderDebug();
        document.getElementById('results').classList.add('visible');
        document.getElementById('status').innerHTML = '';
        initTooltips();
    }
    </script>
</body>
</html>